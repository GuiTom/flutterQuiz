import{_ as r,o as s,c as p,j as e,a as t}from"./chunks/framework.CbQjVMS6.js";const l="/assets/frame_seprate.CSwUe25z.webp",_=JSON.parse('{"title":"第7节：分帧渲染优化","description":"","frontmatter":{},"headers":[],"relativePath":"Chapter2/frame_seprate.md","filePath":"Chapter2/frame_seprate.md","lastUpdated":1770253889000}'),n={name:"Chapter2/frame_seprate.md"};function d(i,a,o,m,c,f){return s(),p("div",null,[...a[0]||(a[0]=[e("h1",{id:"第7节-分帧渲染优化",tabindex:"-1"},[t("第7节：分帧渲染优化 "),e("a",{class:"header-anchor",href:"#第7节-分帧渲染优化","aria-label":'Permalink to "第7节：分帧渲染优化"'},"​")],-1),e("p",null,"设想一个页面中有4个需要显示的widget,他们每个渲染需要10ms,一页渲染完成就需要40ms,超出了一帧的时间16.7ms,就产生了卡帧现象。",-1),e("p",null,"但是如果把这4个widget 分别放到第1帧、第2帧、第3帧、第4帧中去渲染，每一个widget只占用10ms,小于16.7ms，卡帧现象就这么消除了。这让我想起了分期买房，果然在哪里套路都一样...",-1),e("p",null,[e("img",{src:l,alt:"分帧渲染示意图"})],-1),e("p",null,"这个可以说是最简单高效的优化方法了，还有一个实现库keframe",-1),e("p",null,"使用这个库只需要将想要分帧渲染的widget用FrameSeparateWidget包裹起来就好了，当然如果被包裹的widget的尺寸会自适应自身内容的大小，而不是用入参width和height写死，或者由父widget限定死的，那么主要填写一个固定大小的placeHolder以防止widget显示跳变",-1),e("p",null,[t("参考:"),e("a",{href:"https://www.jianshu.com/p/4a36cce7b76d",target:"_blank",rel:"noreferrer"},"https://www.jianshu.com/p/4a36cce7b76d")],-1)])])}const w=r(n,[["render",d]]);export{_ as __pageData,w as default};

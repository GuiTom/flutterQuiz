import{_ as e,o as a,c as n,ag as t}from"./chunks/framework.CbQjVMS6.js";const u=JSON.parse('{"title":"第1节：点击测试","description":"","frontmatter":{},"headers":[],"relativePath":"Chapter4/hit_test.md","filePath":"Chapter4/hit_test.md","lastUpdated":1710416437000}'),i={name:"Chapter4/hit_test.md"};function p(l,s,o,r,d,c){return a(),n("div",null,[...s[0]||(s[0]=[t(`<h1 id="第1节-点击测试" tabindex="-1">第1节：点击测试 <a class="header-anchor" href="#第1节-点击测试" aria-label="Permalink to &quot;第1节：点击测试&quot;">​</a></h1><h3 id="_1-命中测试的起点" tabindex="-1">1. 命中测试的起点 <a class="header-anchor" href="#_1-命中测试的起点" aria-label="Permalink to &quot;1. 命中测试的起点&quot;">​</a></h3><p>一个对象是否可以响应事件，取决于在其对命中测试过程中是否被添加到了 HitTestResult 列表 ，如果没有被添加进去，则后续的事件分发将不会分发给自己。下面我们看一下命中测试的过程：当发生用户事件时，Flutter 会从根节点（<code>RenderView</code>）开始调用它<code>hitTest()</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>@override</span></span>
<span class="line"><span>void hitTest(HitTestResult result, Offset position) {</span></span>
<span class="line"><span>  //从根节点开始进行命中测试</span></span>
<span class="line"><span>  renderView.hitTest(result, position: position); </span></span>
<span class="line"><span>  // 会调用 GestureBinding 中的 hitTest()方法，我们将在下一节中介绍。</span></span>
<span class="line"><span>  super.hitTest(result, position); </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>第一步： renderView 是 RenderView 对应的 RenderObject 对象， RenderObject 对象的 hitTest 方法主要功能是：从该节点出发，按照深度优先的顺序递归遍历子树（渲染树）上的每一个节点并对它们进行命中测试。这个过程称为“渲染树命中测试”。</p><p>第二步：渲染树命中测试完毕后，会调用 GestureBinding 的 hitTest 方法，该方法主要用于处理手势。</p><h3 id="_2-渲染树命中测试过程" tabindex="-1">2.渲染树命中测试过程 <a class="header-anchor" href="#_2-渲染树命中测试过程" aria-label="Permalink to &quot;2.渲染树命中测试过程&quot;">​</a></h3><p>渲染树的命中测试流程就是父节点 hitTest 方法中不断调用子节点 hitTest 方法的递归过程。下面是<code>RenderView</code>的<code>hitTest()</code>源码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// 发起命中测试，position 为事件触发的坐标（如果有的话）。</span></span>
<span class="line"><span>bool hitTest(HitTestResult result, { Offset position }) {</span></span>
<span class="line"><span>  if (child != null)</span></span>
<span class="line"><span>    child.hitTest(result, position: position); //递归对子树进行命中测试</span></span>
<span class="line"><span>  //根节点会始终被添加到HitTestResult列表中</span></span>
<span class="line"><span>  result.add(HitTestEntry(this)); </span></span>
<span class="line"><span>  return true;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>因为 RenderView 只有一个孩子，所以直接调用child.hitTest 即可。如果一个渲染对象有多个子节点，则命中测试逻辑为：如果任意一个子节点通过了命中测试或者当前节点“强行声明”自己通过了命中测试，则当前节点会通过命中测试。</p>`,10)])])}const _=e(i,[["render",p]]);export{u as __pageData,_ as default};

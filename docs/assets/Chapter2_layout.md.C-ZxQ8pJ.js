import{_ as e,o as a,c as r,ag as o}from"./chunks/framework.FundgpKU.js";const s="/flutterQuiz/assets/image-20230925112654036.6ukrWphu.png",i="/flutterQuiz/assets/image-20230925112707609.BqcWxWtz.png",f=JSON.parse('{"title":"第2节：布局优化","description":"","frontmatter":{},"headers":[],"relativePath":"Chapter2/layout.md","filePath":"Chapter2/layout.md","lastUpdated":1770253889000}'),l={name:"Chapter2/layout.md"};function n(d,t,h,c,p,u){return a(),r("div",null,[...t[0]||(t[0]=[o('<h1 id="第2节-布局优化" tabindex="-1">第2节：布局优化 <a class="header-anchor" href="#第2节-布局优化" aria-label="Permalink to &quot;第2节：布局优化&quot;">​</a></h1><h3 id="尽量减少由内部操作引起的布局传递" tabindex="-1">尽量减少由内部操作引起的布局传递 <a class="header-anchor" href="#尽量减少由内部操作引起的布局传递" aria-label="Permalink to &quot;尽量减少由内部操作引起的布局传递&quot;">​</a></h3><p>如果你经常使用 Flutter 编程，你可能已经熟悉了在创建 UI 时 <a href="https://flutter.cn/docs/ui/layout/constraints" target="_blank" rel="noreferrer">布局和约束是如何工作的</a>。你甚至可能已经记住了 Flutter 的基本布局规则： <strong>首先，上层 widget 向下层 widget 传递约束条件；</strong><strong>然后，下层 widget 向上层 widget 传递大小信息；</strong><strong>最后，上层 widget 决定下层 widget 的位置。</strong></p><p>对于一些 widget，特别是网格列表和列表，布局过程中性能代价很大。 Flutter 尽可能在 widget 上只执行一次布局传递，但有时需要再次传递（称为 <strong>内部传递</strong>,<strong>或向上传递</strong>），这可能会降低性能。</p><h4 id="什么是内部传递" tabindex="-1">什么是内部传递？ <a class="header-anchor" href="#什么是内部传递" aria-label="Permalink to &quot;什么是内部传递？&quot;">​</a></h4><p>例如，你想要所有单元格都具有或大或小的效果（或类似需要轮询所有单元格的计算）时，就会发生内部传递。</p><p>例如，考虑一个大型的 <code>卡片</code> 网格列表时。一个网格列表应该有统一大小的单元格，所以布局代码执行了一次传递，从网格列表的根部开始（在 widget 树中），要求网格列表中的 <strong>每个</strong> 卡片（不仅仅是可见的卡片）来返回 <strong>内部</strong> 尺寸—假设没有任何限制，widget 更喜欢这样的尺寸。有了这些信息，底层框架就确定了一个统一的单元格尺寸，并再次重新访问所有的网格单元，告诉每个卡片应该使用什么尺寸。</p><h4 id="调试内部传递" tabindex="-1">调试内部传递 <a class="header-anchor" href="#调试内部传递" aria-label="Permalink to &quot;调试内部传递&quot;">​</a></h4><p>要确认你是否有过多的内部传递，请在 DevTools 中启用 <strong><a href="https://flutter.cn/docs/tools/devtools/performance#track-layouts" target="_blank" rel="noreferrer">布局跟踪 (Track layouts option)</a></strong> （默认情况下是禁用的），并查看应用程序的 <a href="https://flutter.cn/docs/tools/devtools/cpu-profiler#flame-chart" target="_blank" rel="noreferrer">堆栈跟踪 (stack trace)</a> 以了解执行了多少次布局传递。一旦你启用跟踪，内部的时间线事件将被标记为 “$runtimeType intrinsics”。</p><h4 id="避免内部传递" tabindex="-1">避免内部传递 <a class="header-anchor" href="#避免内部传递" aria-label="Permalink to &quot;避免内部传递&quot;">​</a></h4><p>你有几个选择来避免内部传递：</p><ul><li>将单元格设置为固定大小。</li><li>选择一个特定的单元格作为 “锚” —所有单元格的尺寸都将相对于这个单元格。编写一个自定义渲染对象，首先定位子锚点，然后在其周围布置其他子单元。</li></ul><h4 id="小测验" tabindex="-1">小测验 <a class="header-anchor" href="#小测验" aria-label="Permalink to &quot;小测验&quot;">​</a></h4><p>对于以下两段列表布局代码，哪一段发生了内部传递?</p><div style="display:flex;"><img src="'+s+'" width="552" height="230"><img src="'+i+'" width="552" height="293"></div>',15)])])}const _=e(l,[["render",n]]);export{f as __pageData,_ as default};

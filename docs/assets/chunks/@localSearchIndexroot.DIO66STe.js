const t='{"documentCount":105,"nextId":105,"documentIds":{"0":"/flutterQuiz/BUILD_DEPLOY.html#vitepress-构建和部署指南","1":"/flutterQuiz/BUILD_DEPLOY.html#📦-构建生成-html","2":"/flutterQuiz/BUILD_DEPLOY.html#📂-构建输出","3":"/flutterQuiz/BUILD_DEPLOY.html#🚀-部署方式","4":"/flutterQuiz/BUILD_DEPLOY.html#方式-1-本地预览","5":"/flutterQuiz/BUILD_DEPLOY.html#方式-2-部署到-github-pages","6":"/flutterQuiz/BUILD_DEPLOY.html#方式-3-部署到-vercel","7":"/flutterQuiz/BUILD_DEPLOY.html#方式-4-部署到-netlify","8":"/flutterQuiz/BUILD_DEPLOY.html#方式-5-手动部署到任意服务器","9":"/flutterQuiz/BUILD_DEPLOY.html#🔄-开发流程","10":"/flutterQuiz/BUILD_DEPLOY.html#日常开发","11":"/flutterQuiz/BUILD_DEPLOY.html#添加新页面","12":"/flutterQuiz/BUILD_DEPLOY.html#⚠️-注意事项","13":"/flutterQuiz/BUILD_DEPLOY.html#📊-构建统计","14":"/flutterQuiz/BUILD_DEPLOY.html#🆘-常见问题","15":"/flutterQuiz/BUILD_DEPLOY.html#q-构建失败提示-not-supported","16":"/flutterQuiz/BUILD_DEPLOY.html#q-图片无法加载","17":"/flutterQuiz/BUILD_DEPLOY.html#q-修改后没有效果","18":"/flutterQuiz/BUILD_DEPLOY.html#✅-快速命令参考","19":"/flutterQuiz/Chapter1/README.html#第一章-渲染管线","20":"/flutterQuiz/Chapter1/README.html#flutter-app中的线程","21":"/flutterQuiz/Chapter1/README.html#平台线程","22":"/flutterQuiz/Chapter1/README.html#ui-线程","23":"/flutterQuiz/Chapter1/README.html#raster-线程-以前叫-gpu-线程","24":"/flutterQuiz/Chapter1/README.html#i-o线程","25":"/flutterQuiz/Chapter1/key.html#第3节-key与复用","26":"/flutterQuiz/Chapter1/key.html#小测验","27":"/flutterQuiz/Chapter1/key.html#_1-下列关于widget、element的关系正确的是","28":"/flutterQuiz/Chapter1/key.html#_2-下列关于widget-key-的说法正确的是","29":"/flutterQuiz/Chapter1/key.html#_3-问-flutter绘制了两个并排的widget和一个按钮-他们的效果图和实现代码如下","30":"/flutterQuiz/Chapter1/pipeline.html#第1节-渲染流程","31":"/flutterQuiz/Chapter1/pipeline.html#小测验","32":"/flutterQuiz/Chapter1/pipeline.html#_1-对于渲染流管线-以下说法正确的是","33":"/flutterQuiz/Chapter1/pipeline.html#_2-对于绘制-paint-与光栅化-下列说法正确的是","34":"/flutterQuiz/Chapter1/tree.html#第1节-三棵树","35":"/flutterQuiz/Chapter1/tree.html#widget-element-renderobject的关系-他们是如何协作的","36":"/flutterQuiz/Chapter1/tree.html#思考-如果想打印出某个指定widget从开始build到渲染到屏幕上面所花费的时间-可能实现吗","37":"/flutterQuiz/Chapter2/README.html#第二章","38":"/flutterQuiz/Chapter2/frame_seprate.html#第7节-分帧渲染优化","39":"/flutterQuiz/Chapter2/image.html#第3节-图片优化","40":"/flutterQuiz/Chapter2/image.html#图片的性能优化可以从以下三个方面入手","41":"/flutterQuiz/Chapter2/image.html#_1-图片的本地缓存。请求过的图片-缓存在磁盘里面-在有效期之内-都不用再从网络请求了。cached-network-image就是做这个事情的。","42":"/flutterQuiz/Chapter2/image.html#_2-图片在服务端裁剪压缩。一般用户上传的图片如果不经过压缩-所占用的空间和流量是非常高的。服务端裁剪压缩要求按照图片显示空间所占的物理像素获取对应大小的图片-做法同本地的2x和3x图片-也要求按照2x和3x的要求裁剪压缩好存在服务端让客户端按需请求","43":"/flutterQuiz/Chapter2/image.html#_3-让gpu将频繁使用的图片存到gpu的显存里面。在image-widget-外面包裹一个repaintboundary-widget-则gpu有可能将图片缓存到显存-但不是一定的。","44":"/flutterQuiz/Chapter2/layout.html#第2节-布局优化","45":"/flutterQuiz/Chapter2/layout.html#尽量减少由内部操作引起的布局传递","46":"/flutterQuiz/Chapter2/layout.html#什么是内部传递","47":"/flutterQuiz/Chapter2/layout.html#调试内部传递","48":"/flutterQuiz/Chapter2/layout.html#避免内部传递","49":"/flutterQuiz/Chapter2/layout.html#小测验","50":"/flutterQuiz/Chapter2/repaintBoundary.html#第2节-绘制边界","51":"/flutterQuiz/Chapter2/repaintBoundary.html#具体重绘区域规则","52":"/flutterQuiz/Chapter2/offscreen.html#第2节-离屏渲染优化","53":"/flutterQuiz/Chapter2/offscreen.html#离屏渲染-off-screen-rendering-是指在屏幕之外或独立于屏幕渲染的一个过程-它通常发生在图形硬件加速的图形绘制中。离屏渲染在某些情况下是必要的-但也可能会对性能产生负面影响-因此需要谨慎使用。","54":"/flutterQuiz/Chapter2/offscreen.html#什么情况下会发生离屏渲染-以下情况可能发生离屏渲染","55":"/flutterQuiz/Chapter2/offscreen.html#为什么需要离屏渲染","56":"/flutterQuiz/Chapter2/offscreen.html#离屏渲染的性能影响","57":"/flutterQuiz/Chapter2/offscreen.html#如何优化离屏渲染-为了优化性能-开发者可以采取以下措施","58":"/flutterQuiz/Chapter2/offscreen.html#小实验","59":"/flutterQuiz/Chapter2/offscreen.html#以下是我在小米mi6x手机上测得的帧率","60":"/flutterQuiz/Chapter2/offscreen.html#小测验","61":"/flutterQuiz/Chapter2/offscreen.html#_1-下列说法正确的是","62":"/flutterQuiz/Chapter2/offscreen.html#_2-下列关关于layer树与光栅化的说法-正确的是","63":"/flutterQuiz/Chapter2/widet_build.html#第1节-widget重建优化","64":"/flutterQuiz/Chapter2/widet_build.html#_1-尽可能减少setstate的粒度","65":"/flutterQuiz/Chapter2/widet_build.html#_2-对用于构建子widget的build方法的执行流不要调用widget-构造方法以外的耗时方法。","66":"/flutterQuiz/Chapter2/widet_build.html#_3-能够合法地被const-修饰的widget构造函数的调用生成的widget对象不会被重建。例如const-sizedbox-。尽可能用const-关键字修饰widget-构造方法的调用。","67":"/flutterQuiz/Chapter2/widet_build.html#_4-对于不能被const修饰的widget构造函数调用生成的widget对象-可以用全局变量或其他不会在某段时间中销毁的变量引用起来-做一个懒加载处理-复用这个widget-避免重建。","68":"/flutterQuiz/Chapter2/widet_build.html#_5-对于例如listview和gridview这样的列表widget-设置其屏幕外缓存区域cachedextend属性-将滑出屏幕外的-element和renderobject有限度地缓存起来-避免不必要的重建","69":"/flutterQuiz/Chapter3/README.html#第三章-线程-isolate-异步","70":"/flutterQuiz/Chapter3/thread.html#第1节-线程模型","71":"/flutterQuiz/Chapter3/thread.html#如何处理耗时的操作-不同语言有不同的处理方式","72":"/flutterQuiz/Chapter3/thread.html#隐式调用","73":"/flutterQuiz/Chapter3/thread.html#显式调用","74":"/flutterQuiz/Chapter4/README.html#第五章-生僻语法","75":"/flutterQuiz/Chapter4/gensture_arena.html#第2节-手势竞争","76":"/flutterQuiz/Chapter4/gensture_arena.html#两个特殊的例子","77":"/flutterQuiz/Chapter4/gensture_arena.html#eagergesturerecognizer-急切胜出-有些手势-如点击-tap-可能在某些条件下立刻宣布胜出-而不给其他手势竞争的机会。","78":"/flutterQuiz/Chapter4/gensture_arena.html#手势透传-如果你希望父子组件同时动-例如-滑动子列表到底部后带动父列表-通常不能通过竞技场默认逻辑实现-而需要使用特殊的-rawgesturedetector-或者自定义手势识别器来手动管理-acceptgesture。","79":"/flutterQuiz/Chapter4/gensture_arena.html#见-https-github-com-guitom-flutterquiz-blob-master-examples-lib-chapter-4-user-interaction-page-dart","80":"/flutterQuiz/Chapter3/async.html#第2节-异步","81":"/flutterQuiz/Chapter3/async.html#单线程的异步操作","82":"/flutterQuiz/Chapter3/async.html#什么是事件循环","83":"/flutterQuiz/Chapter3/async.html#dart-中的异步","84":"/flutterQuiz/Chapter3/async.html#什么是协程","85":"/flutterQuiz/Chapter3/async.html#async、await原理","86":"/flutterQuiz/Chapter3/async.html#completer","87":"/flutterQuiz/Chapter4/live_circle.html#_1-state生命周期-statefulwidget-组件的生命周期","88":"/flutterQuiz/Chapter4/live_circle.html#_2-build","89":"/flutterQuiz/Chapter4/live_circle.html#_3-didchangedependencie与didupdatewidget的作用","90":"/flutterQuiz/Chapter4/live_circle.html#_5-app生命周期监听applifecyclelistener","91":"/flutterQuiz/Chapter5/README.html#第五章-生僻语法","92":"/flutterQuiz/Chapter4/hittest_behavior.html#histtestbehavor有三个属性","93":"/flutterQuiz/Chapter4/hittest_behavior.html#例子","94":"/flutterQuiz/Chapter4/hittest_behavior.html#参考","95":"/flutterQuiz/Chapter5/yield.html#第2节-yield","96":"/flutterQuiz/Chapter4/hit_test.html#第1节-点击测试","97":"/flutterQuiz/Chapter4/hit_test.html#_1-命中测试的起点","98":"/flutterQuiz/Chapter4/hit_test.html#_2-渲染树命中测试过程","99":"/flutterQuiz/README.html#前言","100":"/flutterQuiz/README.html#地址-https-guitom-github-io-flutterquiz","101":"/flutterQuiz/examples/README.html#study","102":"/flutterQuiz/examples/README.html#getting-started","103":"/flutterQuiz/examples/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.html#launch-screen-assets","104":"/flutterQuiz/#关于本书"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[2,1,1],"1":[3,2,32],"2":[2,2,18],"3":[2,2,1],"4":[3,4,11],"5":[5,4,61],"6":[4,4,21],"7":[4,4,20],"8":[3,4,7],"9":[2,2,1],"10":[1,4,29],"11":[1,4,14],"12":[2,2,30],"13":[2,2,12],"14":[2,2,1],"15":[6,4,17],"16":[2,4,8],"17":[2,4,4],"18":[2,2,11],"19":[2,1,15],"20":[2,2,9],"21":[1,4,13],"22":[2,4,21],"23":[5,4,27],"24":[2,4,15],"25":[2,1,1],"26":[1,2,1],"27":[4,3,14],"28":[5,3,16],"29":[5,3,87],"30":[2,1,1],"31":[1,2,1],"32":[4,3,44],"33":[6,3,28],"34":[2,1,1],"35":[5,2,3],"36":[4,7,35],"37":[1,1,28],"38":[2,1,31],"39":[2,1,9],"40":[2,2,1],"41":[10,4,22],"42":[7,4,6],"43":[8,4,6],"44":[2,1,1],"45":[1,2,32],"46":[2,3,27],"47":[1,3,19],"48":[1,3,9],"49":[1,3,3],"50":[2,1,91],"51":[2,2,18],"52":[2,1,1],"53":[10,2,2],"54":[3,2,27],"55":[2,2,5],"56":[2,2,6],"57":[4,2,8],"58":[1,2,77],"59":[1,3,20],"60":[1,2,1],"61":[3,4,28],"62":[4,4,21],"63":[2,1,19],"64":[2,2,1],"65":[4,2,1],"66":[9,2,1],"67":[7,2,1],"68":[6,2,1],"69":[4,1,1],"70":[2,1,1],"71":[2,2,15],"72":[1,4,21],"73":[1,4,53],"74":[2,1,1],"75":[2,1,49],"76":[2,2,1],"77":[8,4,1],"78":[10,4,1],"79":[2,13,1],"80":[2,1,1],"81":[1,2,14],"82":[1,2,37],"83":[2,2,16],"84":[1,4,13],"85":[2,4,57],"86":[1,4,41],"87":[3,1,61],"88":[2,3,44],"89":[2,3,1],"90":[2,3,148],"91":[2,1,1],"92":[2,1,47],"93":[1,1,23],"94":[2,1,26],"95":[2,1,76],"96":[2,1,1],"97":[2,2,44],"98":[2,2,37],"99":[1,1,2],"100":[2,1,11],"101":[1,1,5],"102":[2,1,46],"103":[3,1,39],"104":[1,1,9]},"averageFieldLength":[2.780952380952381,2.4857142857142844,19.99047619047621],"storedFields":{"0":{"title":"VitePress 构建和部署指南","titles":[]},"1":{"title":"📦 构建生成 HTML","titles":["VitePress 构建和部署指南"]},"2":{"title":"📂 构建输出","titles":["VitePress 构建和部署指南"]},"3":{"title":"🚀 部署方式","titles":["VitePress 构建和部署指南"]},"4":{"title":"方式 1: 本地预览","titles":["VitePress 构建和部署指南","🚀 部署方式"]},"5":{"title":"方式 2: 部署到 GitHub Pages","titles":["VitePress 构建和部署指南","🚀 部署方式"]},"6":{"title":"方式 3: 部署到 Vercel","titles":["VitePress 构建和部署指南","🚀 部署方式"]},"7":{"title":"方式 4: 部署到 Netlify","titles":["VitePress 构建和部署指南","🚀 部署方式"]},"8":{"title":"方式 5: 手动部署到任意服务器","titles":["VitePress 构建和部署指南","🚀 部署方式"]},"9":{"title":"🔄 开发流程","titles":["VitePress 构建和部署指南"]},"10":{"title":"日常开发","titles":["VitePress 构建和部署指南","🔄 开发流程"]},"11":{"title":"添加新页面","titles":["VitePress 构建和部署指南","🔄 开发流程"]},"12":{"title":"⚠️ 注意事项","titles":["VitePress 构建和部署指南"]},"13":{"title":"📊 构建统计","titles":["VitePress 构建和部署指南"]},"14":{"title":"🆘 常见问题","titles":["VitePress 构建和部署指南"]},"15":{"title":"Q: 构建失败提示 &quot;Not supported&quot;","titles":["VitePress 构建和部署指南","🆘 常见问题"]},"16":{"title":"Q: 图片无法加载","titles":["VitePress 构建和部署指南","🆘 常见问题"]},"17":{"title":"Q: 修改后没有效果","titles":["VitePress 构建和部署指南","🆘 常见问题"]},"18":{"title":"✅ 快速命令参考","titles":["VitePress 构建和部署指南"]},"19":{"title":"第一章 渲染管线","titles":[]},"20":{"title":"Flutter app中的线程","titles":["第一章 渲染管线"]},"21":{"title":"平台线程","titles":["第一章 渲染管线","Flutter app中的线程"]},"22":{"title":"UI 线程","titles":["第一章 渲染管线","Flutter app中的线程"]},"23":{"title":"Raster 线程（以前叫 GPU 线程）","titles":["第一章 渲染管线","Flutter app中的线程"]},"24":{"title":"I/O线程","titles":["第一章 渲染管线","Flutter app中的线程"]},"25":{"title":"第3节：key与复用","titles":[]},"26":{"title":"小测验","titles":["第3节：key与复用"]},"27":{"title":"1.     下列关于widget、element的关系正确的是:","titles":["第3节：key与复用","小测验"]},"28":{"title":"2.     下列关于widget key 的说法正确的是:","titles":["第3节：key与复用","小测验"]},"29":{"title":"3.  问:flutter绘制了两个并排的widget和一个按钮，他们的效果图和实现代码如下:","titles":["第3节：key与复用","小测验"]},"30":{"title":"第1节:渲染流程","titles":[]},"31":{"title":"小测验","titles":["第1节:渲染流程"]},"32":{"title":"1.对于渲染流管线,以下说法正确的是?","titles":["第1节:渲染流程","小测验"]},"33":{"title":"2.对于绘制(paint)与光栅化,下列说法正确的是?","titles":["第1节:渲染流程","小测验"]},"34":{"title":"第1节：三棵树","titles":[]},"35":{"title":"Widget\\\\Element\\\\RenderObject的关系？他们是如何协作的？","titles":["第1节：三棵树"]},"36":{"title":"思考：如果想打印出某个指定widget从开始build到渲染到屏幕上面所花费的时间，可能实现吗？","titles":["第1节：三棵树","Widget\\\\Element\\\\RenderObject的关系？他们是如何协作的？"]},"37":{"title":"第二章","titles":[]},"38":{"title":"第7节：分帧渲染优化","titles":[]},"39":{"title":"第3节：图片优化","titles":[]},"40":{"title":"图片的性能优化可以从以下三个方面入手:","titles":["第3节：图片优化"]},"41":{"title":"1.图片的本地缓存。请求过的图片，缓存在磁盘里面，在有效期之内，都不用再从网络请求了。cached_network_image就是做这个事情的。","titles":["第3节：图片优化","图片的性能优化可以从以下三个方面入手:"]},"42":{"title":"2.图片在服务端裁剪压缩。一般用户上传的图片如果不经过压缩，所占用的空间和流量是非常高的。服务端裁剪压缩要求按照图片显示空间所占的物理像素获取对应大小的图片，做法同本地的2x和3x图片，也要求按照2x和3x的要求裁剪压缩好存在服务端让客户端按需请求","titles":["第3节：图片优化","图片的性能优化可以从以下三个方面入手:"]},"43":{"title":"3. 让GPU将频繁使用的图片存到GPU的显存里面。在Image widget 外面包裹一个RepaintBoundary widget，则GPU有可能将图片缓存到显存,但不是一定的。","titles":["第3节：图片优化","图片的性能优化可以从以下三个方面入手:"]},"44":{"title":"第2节：布局优化","titles":[]},"45":{"title":"尽量减少由内部操作引起的布局传递","titles":["第2节：布局优化"]},"46":{"title":"什么是内部传递？","titles":["第2节：布局优化","尽量减少由内部操作引起的布局传递"]},"47":{"title":"调试内部传递","titles":["第2节：布局优化","尽量减少由内部操作引起的布局传递"]},"48":{"title":"避免内部传递","titles":["第2节：布局优化","尽量减少由内部操作引起的布局传递"]},"49":{"title":"小测验","titles":["第2节：布局优化","尽量减少由内部操作引起的布局传递"]},"50":{"title":"第2节：绘制边界","titles":[]},"51":{"title":"具体重绘区域规则:","titles":["第2节：绘制边界"]},"52":{"title":"第2节：离屏渲染优化","titles":[]},"53":{"title":"离屏渲染（Off-screen rendering）是指在屏幕之外或独立于屏幕渲染的一个过程，它通常发生在图形硬件加速的图形绘制中。离屏渲染在某些情况下是必要的，但也可能会对性能产生负面影响，因此需要谨慎使用。","titles":["第2节：离屏渲染优化"]},"54":{"title":"什么情况下会发生离屏渲染？ 以下情况可能发生离屏渲染：","titles":["第2节：离屏渲染优化"]},"55":{"title":"为什么需要离屏渲染？","titles":["第2节：离屏渲染优化"]},"56":{"title":"离屏渲染的性能影响：","titles":["第2节：离屏渲染优化"]},"57":{"title":"如何优化离屏渲染： 为了优化性能，开发者可以采取以下措施：","titles":["第2节：离屏渲染优化"]},"58":{"title":"小实验","titles":["第2节：离屏渲染优化"]},"59":{"title":"以下是我在小米Mi6X手机上测得的帧率","titles":["第2节：离屏渲染优化","小实验"]},"60":{"title":"小测验","titles":["第2节：离屏渲染优化"]},"61":{"title":"1.下列说法正确的是( )","titles":["第2节：离屏渲染优化","小测验","小实验"]},"62":{"title":"2. 下列关关于layer树与光栅化的说法，正确的是( )","titles":["第2节：离屏渲染优化","小测验","小实验"]},"63":{"title":"第1节：widget重建优化","titles":[]},"64":{"title":"1.尽可能减少setState的粒度","titles":["第1节：widget重建优化"]},"65":{"title":"2.对用于构建子widget的build方法的执行流不要调用widget 构造方法以外的耗时方法。","titles":["第1节：widget重建优化"]},"66":{"title":"3. 能够合法地被const 修饰的widget构造函数的调用生成的widget对象不会被重建。例如const SizedBox()。尽可能用const 关键字修饰widget 构造方法的调用。","titles":["第1节：widget重建优化"]},"67":{"title":"4. 对于不能被const修饰的widget构造函数调用生成的widget对象，可以用全局变量或其他不会在某段时间中销毁的变量引用起来，做一个懒加载处理，复用这个widget，避免重建。","titles":["第1节：widget重建优化"]},"68":{"title":"5.对于例如listView和gridview这样的列表widget,设置其屏幕外缓存区域cachedExtend属性，将滑出屏幕外的 element和RenderObject有限度地缓存起来，避免不必要的重建","titles":["第1节：widget重建优化"]},"69":{"title":"第三章 线程/isolate/异步","titles":[]},"70":{"title":"第1节：线程模型","titles":[]},"71":{"title":"如何处理耗时的操作? 不同语言有不同的处理方式","titles":["第1节：线程模型"]},"72":{"title":"隐式调用","titles":["第1节：线程模型","如何处理耗时的操作? 不同语言有不同的处理方式"]},"73":{"title":"显式调用","titles":["第1节：线程模型","如何处理耗时的操作? 不同语言有不同的处理方式"]},"74":{"title":"第五章 生僻语法","titles":[]},"75":{"title":"第2节：手势竞争","titles":[]},"76":{"title":"两个特殊的例子:","titles":["第2节：手势竞争"]},"77":{"title":"EagerGestureRecognizer（急切胜出）：有些手势（如点击 Tap）可能在某些条件下立刻宣布胜出，而不给其他手势竞争的机会。","titles":["第2节：手势竞争","两个特殊的例子:"]},"78":{"title":"手势透传：如果你希望父子组件同时动（例如：滑动子列表到底部后带动父列表），通常不能通过竞技场默认逻辑实现，而需要使用特殊的 RawGestureDetector 或者自定义手势识别器来手动管理 acceptGesture。","titles":["第2节：手势竞争","两个特殊的例子:"]},"79":{"title":"见:","titles":["第2节：手势竞争","两个特殊的例子:","手势透传：如果你希望父子组件同时动（例如：滑动子列表到底部后带动父列表），通常不能通过竞技场默认逻辑实现，而需要使用特殊的 RawGestureDetector 或者自定义手势识别器来手动管理 acceptGesture。"]},"80":{"title":"第2节：异步","titles":[]},"81":{"title":"单线程的异步操作","titles":["第2节：异步"]},"82":{"title":"什么是事件循环","titles":["第2节：异步"]},"83":{"title":"Dart 中的异步","titles":["第2节：异步"]},"84":{"title":"什么是协程","titles":["第2节：异步","Dart 中的异步"]},"85":{"title":"async、await原理","titles":["第2节：异步","Dart 中的异步"]},"86":{"title":"Completer","titles":["第2节：异步","Dart 中的异步"]},"87":{"title":"1. State生命周期|StatefulWidget 组件的生命周期","titles":[]},"88":{"title":"2. build","titles":["1. State生命周期|StatefulWidget 组件的生命周期"]},"89":{"title":"3. didChangeDependencie与didUpdateWidget的作用","titles":["1. State生命周期|StatefulWidget 组件的生命周期"]},"90":{"title":"5. App生命周期监听AppLifecycleListener","titles":["1. State生命周期|StatefulWidget 组件的生命周期"]},"91":{"title":"第五章 生僻语法","titles":[]},"92":{"title":"histTestBehavor有三个属性：","titles":[]},"93":{"title":"例子","titles":[]},"94":{"title":"参考:","titles":[]},"95":{"title":"第2节：yield","titles":[]},"96":{"title":"第1节：点击测试","titles":[]},"97":{"title":"1. 命中测试的起点","titles":["第1节：点击测试"]},"98":{"title":"2.渲染树命中测试过程","titles":["第1节：点击测试"]},"99":{"title":"前言","titles":[]},"100":{"title":"地址:","titles":["前言"]},"101":{"title":"study","titles":[]},"102":{"title":"Getting Started","titles":["study"]},"103":{"title":"Launch Screen Assets","titles":[]},"104":{"title":"关于本书","titles":[]}},"dirtCount":0,"index":[["提升应用开发能力",{"2":{"104":1}}],["掌握性能优化技巧",{"2":{"104":1}}],["您将深入理解",{"2":{"104":1}}],["​",{"2":{"100":15}}],["​\\t\\t\\t\\t\\t\\t\\t",{"2":{"58":1,"100":3}}],["​\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",{"2":{"100":1}}],["​\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t图一",{"2":{"35":1}}],["​\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",{"2":{"59":1}}],["​\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t图二",{"2":{"50":1,"59":1}}],["​\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t图一",{"2":{"19":1,"50":1}}],["​\\t\\t\\t\\t\\t\\t\\t\\t图二",{"2":{"24":1}}],["地址",{"0":{"100":1}}],["前言",{"0":{"99":1},"1":{"100":1}}],["前两人呆在一个叫cpu的车间里",{"2":{"19":1}}],["自己通过了命中测试",{"2":{"98":1}}],["强行声明",{"2":{"98":1}}],["根节点会始终被添加到hittestresult列表中",{"2":{"98":1}}],["根据父widget传递过来的初始化配置数据",{"2":{"88":1}}],["递归对子树进行命中测试",{"2":{"98":1}}],["发起命中测试",{"2":{"98":1}}],["发出完成信号",{"2":{"86":1}}],["源码",{"2":{"98":1}}],["按照深度优先的顺序递归遍历子树",{"2":{"97":1}}],["列表",{"2":{"97":1}}],["取决于在其对命中测试过程中是否被添加到了",{"2":{"97":1}}],["命中测试的起点",{"0":{"97":1}}],["\\tprint",{"2":{"95":1}}],["共打印出",{"2":{"95":1}}],["9",{"2":{"95":1}}],["7",{"2":{"95":1}}],["7ms",{"2":{"38":2}}],["6",{"2":{"95":1,"100":1}}],["同步数据生成器",{"2":{"95":1}}],["同步数据序列表示iterable的实例",{"2":{"95":1}}],["同时其",{"2":{"92":1}}],["同时",{"2":{"59":1}}],["数据序列可以是同步的或异步的",{"2":{"95":1}}],["预定义值等",{"2":{"95":1}}],["预览",{"2":{"18":1}}],["预览生产版本",{"2":{"10":1}}],["|",{"2":{"94":1}}],["打印",{"2":{"95":1}}],["打印出第一帧渲染所需要的时间",{"2":{"36":1}}],["打开",{"2":{"93":1}}],["若去掉颜色而加上behavior",{"2":{"93":1}}],["注意",{"2":{"92":1}}],["注意事项",{"0":{"12":1}}],["值是什么",{"2":{"92":1}}],["值此时取决于",{"2":{"92":1}}],["值始终为",{"2":{"92":1}}],["简书",{"2":{"90":1}}],["简单来讲",{"2":{"75":1}}],["遥遥领先系列|一文教你完全掌握生命周期",{"2":{"90":1}}],["通过系统化的学习",{"2":{"104":1}}],["通过addpostframecallback实现",{"2":{"90":1}}],["通常不能通过竞技场默认逻辑实现",{"0":{"78":1},"1":{"79":1}}],["依然使用万能的widgetsbinding来实现",{"2":{"90":1}}],["插入消息队列",{"2":{"90":1}}],["插入视图树",{"2":{"87":1}}],["形成更完整的生命周期链条",{"2":{"90":1}}],["四种",{"2":{"90":1}}],["至少一个视图是可见的",{"2":{"90":1}}],["表示",{"2":{"90":1}}],["优点",{"2":{"90":1}}],["优化后的",{"2":{"2":1}}],["新版本生命周期回调",{"2":{"90":1}}],["控制台打印的app生命周期变化则变成了",{"2":{"90":1}}],["控制台打印的app生命周期变化如下",{"2":{"90":1}}],["观察控制台输出的app状态",{"2":{"90":1}}],["观察dev",{"2":{"58":1}}],["处于具有输入焦点且可见的正在运行的状态",{"2":{"90":1}}],["处在不活动状态",{"2":{"90":1}}],["处理结果",{"2":{"72":1}}],["语言变化",{"2":{"90":1}}],["屏幕亮度",{"2":{"90":1}}],["相应更直观",{"2":{"90":1}}],["相关特性回调",{"2":{"90":1}}],["相信没有多少人会傻到将整张图的背景和人物都擦掉",{"2":{"50":1}}],["生成器的功能以自然的方式生成数据项",{"2":{"95":1}}],["生命周期图2",{"2":{"90":1}}],["生命周期回调",{"2":{"90":1}}],["生命周期变化",{"2":{"90":1}}],["生僻语法",{"0":{"74":1,"91":1}}],["系统亮度变化",{"2":{"90":1}}],["系统窗口相关改变回调",{"2":{"90":1}}],["各种变化",{"2":{"90":1}}],["状态发生变化的时候调用",{"2":{"88":1}}],["差不多",{"2":{"88":1}}],["被其他app档在前面了",{"2":{"90":1}}],["被暂时从视图树中移除时会调用这个方法",{"2":{"88":1}}],["被flutter调用",{"2":{"87":1}}],["于是调用build",{"2":{"88":1}}],["经过以上步骤",{"2":{"88":1}}],["作用是构建视图",{"2":{"88":1}}],["作业意味着在某一时刻",{"2":{"32":1}}],["之外的操作",{"2":{"88":1}}],["千万不要在",{"2":{"88":1}}],["返回一个steam对象",{"2":{"95":1}}],["返回一个",{"2":{"95":1}}],["返回值可能为",{"2":{"92":1}}],["返回值始终为",{"2":{"92":1}}],["返回",{"2":{"92":3}}],["返回要渲染的",{"2":{"88":1}}],["返回结果",{"2":{"73":1}}],["需要重新渲染的时候",{"2":{"88":1}}],["需要提到一点是",{"2":{"41":1}}],["后台",{"2":{"90":1}}],["后调用",{"2":{"87":1}}],["后重新构建",{"2":{"12":1}}],["决定了widget最初的呈现效果",{"2":{"87":1}}],["决定下层",{"2":{"45":1}}],["已经被加载到渲染树里了",{"2":{"87":1}}],["类似于",{"2":{"87":1}}],["类似位图",{"2":{"33":1}}],["必须要实现",{"2":{"87":1}}],["必须使用",{"2":{"12":1,"15":1}}],["里做除了创建",{"2":{"88":1}}],["里创建",{"2":{"87":1}}],["里面的performance",{"2":{"36":1}}],["销毁时调用",{"2":{"88":1}}],["销毁",{"2":{"87":1}}],["更新",{"2":{"87":1}}],["更喜欢这样的尺寸",{"2":{"46":1}}],["初始化之前所处的默认状态",{"2":{"90":1}}],["初始化当前",{"2":{"87":1}}],["初始化",{"2":{"87":1}}],["组件必然会通过命中测试",{"2":{"92":2}}],["组件是否通过命中测试取决于子组件是否通过命中测试",{"2":{"92":1}}],["组件如何表现",{"2":{"92":1}}],["组件的生命周期",{"0":{"87":1},"1":{"88":1,"89":1,"90":1}}],["组件只有在指定",{"2":{"61":1}}],["启动异步操作",{"2":{"86":1}}],["启动开发服务器",{"2":{"10":1}}],["模拟一个2秒的延迟",{"2":{"86":1}}],["模拟一个异步操作",{"2":{"86":1}}],["模式的裁剪",{"2":{"41":1}}],["队列",{"2":{"85":2}}],["队列有点类似",{"2":{"82":1}}],["由于并没有开启新的线程",{"2":{"85":1}}],["看某个协程是否任务已经处理完成",{"2":{"85":1}}],["过一段时间",{"2":{"85":1}}],["也可能为",{"2":{"92":1}}],["也就是说只要有一个子节点通过命中测试",{"2":{"92":1}}],["也就是await标志的位置",{"2":{"85":1}}],["也就是后面的代码或其他协程代码",{"2":{"85":1}}],["也要求按照2x和3x的要求裁剪压缩好存在服务端让客户端按需请求",{"0":{"42":1}}],["协程在执行时",{"2":{"85":1}}],["协程分为无线协程和有线协程",{"2":{"84":1}}],["无响应",{"2":{"93":1}}],["无法处理用户响应",{"2":{"90":1}}],["无线协程在离开当前调用位置时",{"2":{"84":1}}],["无论是localkey还是globalkey都是为了标识element和widget",{"2":{"28":1}}],["用于处理异步操作",{"2":{"86":1}}],["用于标明函数是一个异步函数",{"2":{"83":1}}],["用来等待耗时操作的返回结果",{"2":{"83":1}}],["来分别满足不同的需求",{"2":{"90":1}}],["来保证在组件渲染后进行相关操作",{"2":{"90":1}}],["来接收父widget传递的初始化ui配置数据",{"2":{"87":1}}],["来创建一个state",{"2":{"87":1}}],["来处理返回的结果",{"2":{"83":1}}],["来返回",{"2":{"46":1}}],["我们将在下一节中介绍",{"2":{"97":1}}],["我们试着切换一下前",{"2":{"90":1}}],["我们可以通过view",{"2":{"90":1}}],["我们可以通过构造方法",{"2":{"87":1}}],["我们可以利用widgetsbindingobserver监听",{"2":{"90":1}}],["我们需要在这个函数中",{"2":{"88":1}}],["我们需要将整张图片重新画一遍",{"2":{"50":1}}],["我们通常通过then",{"2":{"83":1}}],["延时操作的一个封装",{"2":{"83":1}}],["事件的优先级比",{"2":{"82":1}}],["消息等外部事件",{"2":{"82":1}}],["接收其他",{"2":{"82":1}}],["函数并运行",{"2":{"82":1}}],["非阻塞式调用",{"2":{"81":1}}],["非离屏渲染的帧率",{"2":{"59":1}}],["调度",{"2":{"85":1}}],["调用结束后",{"2":{"87":1}}],["调用结果返回之前",{"2":{"81":1}}],["调用执行之后",{"2":{"81":1}}],["调用线程只有在得到调用结果之后才会继续执行",{"2":{"81":1}}],["调试的时候打开dev",{"2":{"50":1}}],["调试内部传递",{"0":{"47":1}}],["调试分析工具",{"2":{"37":1}}],["阻塞式调用",{"2":{"81":1}}],["应该使用isolate开辟新的线程去执行",{"2":{"85":1}}],["应用程序启动后",{"2":{"82":1}}],["应用程序大部分时间是处于空闲状态的",{"2":{"81":1}}],["应用很像",{"2":{"82":1}}],["应使用",{"2":{"16":1}}],["见",{"0":{"79":1}}],["滑动子列表到底部后带动父列表",{"0":{"78":1},"1":{"79":1}}],["急切胜出",{"0":{"77":1}}],["两个特殊的例子",{"0":{"76":1},"1":{"77":1,"78":1,"79":1}}],["父listview会动吗",{"2":{"75":1}}],["假设有一个listview",{"2":{"75":1}}],["假设没有任何限制",{"2":{"46":1}}],["哪个轴在本次滑动事件竞争中就胜出",{"2":{"75":1}}],["哪个轴的大",{"2":{"75":1}}],["哪一段发生了内部传递",{"2":{"49":1}}],["其返回值类型是future类型",{"2":{"83":1}}],["其余的",{"2":{"75":1}}],["其实也很难看出差别",{"2":{"59":1}}],["其实离屏渲染",{"2":{"59":1}}],["胜出者的",{"2":{"75":1}}],["默认情况最终只有一个",{"2":{"75":2}}],["默认情况下是禁用的",{"2":{"47":1}}],["去竞争本次事件的处理权",{"2":{"75":2}}],["竞技场管理者",{"2":{"75":1}}],["竞技场",{"2":{"75":2}}],["竞争者可以宣布自己是否胜出",{"2":{"75":1}}],["竞争者",{"2":{"75":4}}],["正常情况下应该是手势直接作用的对象应该来处理手势",{"2":{"75":1}}],["正确的是",{"0":{"62":1}}],["手势事件",{"2":{"82":1}}],["手势透传",{"0":{"78":1},"1":{"79":1}}],["手势识别才映入了手势竞技场",{"2":{"75":1}}],["手势竞争",{"0":{"75":1},"1":{"76":1,"77":1,"78":1,"79":1}}],["手动部署到任意服务器",{"0":{"8":1}}],["kill",{"2":{"73":2}}],["keframe",{"2":{"37":1}}],["key",{"0":{"28":1},"2":{"29":7,"58":1}}],["key与复用",{"0":{"25":1},"1":{"26":1,"27":1,"28":1,"29":1}}],["关于本书",{"0":{"104":1}}],["关于",{"2":{"94":1}}],["关闭",{"2":{"73":1}}],["关键字修饰widget",{"0":{"66":1}}],["等待异步操作完成",{"2":{"86":1}}],["等待",{"2":{"73":1}}],["创建一个widget然后返回",{"2":{"88":1}}],["创建一个completer",{"2":{"86":1}}],["创建完后调用的第一个方法",{"2":{"87":1}}],["创建",{"2":{"73":1,"87":1}}],["创建蓝色方格",{"2":{"58":1}}],["+=",{"2":{"73":1}}],["显式调用",{"0":{"73":1}}],["显然不会",{"2":{"61":1}}],["执行到async则表示进入一个协程",{"2":{"85":1}}],["执行一些计算密集型的任务",{"2":{"72":1}}],["执行昂贵的操作",{"2":{"24":1}}],["隐式调用",{"0":{"72":1}}],["都会被调用",{"2":{"88":1}}],["都是一个",{"2":{"75":2}}],["都是主要基于单线程加事件循环来完成耗时操作的处理",{"2":{"71":1}}],["都不用再从网络请求了",{"0":{"41":1}}],["单次",{"2":{"90":1}}],["单次frame绘制回调",{"2":{"90":1}}],["单线程的异步操作",{"0":{"81":1}}],["单线程+事件循环",{"2":{"71":1}}],["单元",{"2":{"23":1}}],["再配合当前",{"2":{"90":1}}],["再通过线程间通信的方式",{"2":{"71":1}}],["再观察火焰图上的帧率",{"2":{"58":1}}],["比如为状态变量设定默认值",{"2":{"87":1}}],["比如网络请求",{"2":{"86":1}}],["比如",{"2":{"71":2}}],["多线程",{"2":{"71":1}}],["异步数据生成器",{"2":{"95":1}}],["异步数据序列表示stream`的实例",{"2":{"95":1}}],["异步操作完成",{"2":{"86":1}}],["异步",{"0":{"69":1,"80":1},"1":{"81":1,"82":1,"83":1,"84":1,"85":1,"86":1}}],["设置其屏幕外缓存区域cachedextend属性",{"0":{"68":1}}],["设想一个页面中有4个需要显示的widget",{"2":{"38":1}}],["复用这个widget",{"0":{"67":1}}],["做一个懒加载处理",{"0":{"67":1}}],["做法同本地的2x和3x图片",{"0":{"42":1}}],["修饰的widget构造函数的调用生成的widget对象不会被重建",{"0":{"66":1}}],["修改后没有效果",{"0":{"17":1}}],["修改",{"2":{"1":1}}],["能够合法地被const",{"0":{"66":1}}],["构造方法是state生命周期的起点",{"2":{"87":1}}],["构造方法的调用",{"0":{"66":1}}],["构造方法以外的耗时方法",{"0":{"65":1}}],["构建",{"2":{"18":1}}],["构建失败提示",{"0":{"15":1}}],["构建时间",{"2":{"13":1}}],["构建统计",{"0":{"13":1}}],["构建前检查",{"2":{"12":1}}],["构建输出",{"0":{"2":1}}],["构建完成后",{"2":{"1":1}}],["构建生产版本",{"2":{"1":1,"10":1}}],["构建生成",{"0":{"1":1}}],["构建和部署指南",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1}}],["视图中勾选",{"2":{"63":1}}],["性能开销还是非常小的",{"2":{"63":1}}],["那就要进行多次光栅化了",{"2":{"62":1}}],["那么被gpu缓存的图片将显示成棋盘网格",{"2":{"43":1}}],["那么主要填写一个固定大小的placeholder以防止widget显示跳变",{"2":{"38":1}}],["阴影等",{"2":{"62":1}}],["裁剪",{"2":{"62":1}}],["即可",{"2":{"98":1}}],["即offscreenrender",{"2":{"61":1}}],["即光栅化",{"2":{"19":1}}],["透明度小于1的opacity",{"2":{"61":2}}],["标识是离屏渲染的区域",{"2":{"59":1}}],["纵向间距为5",{"2":{"58":1}}],["横向间距为5",{"2":{"58":1}}],["点我展开查看代码",{"2":{"58":1}}],["点击测试",{"0":{"96":1},"1":{"97":1,"98":1}}],["点击有响应",{"2":{"93":1}}],["点击查看答案解析",{"2":{"61":1,"62":1}}],["点击",{"2":{"6":1,"7":1}}],["开始调用它hittest",{"2":{"97":1}}],["开始执行",{"2":{"82":1}}],["开启了clipbehavior",{"2":{"59":1}}],["开启离屏渲染标记开启运行以下代码",{"2":{"58":1}}],["开发者可以采取以下措施",{"0":{"57":1}}],["开发",{"2":{"18":1}}],["开发流程",{"0":{"9":1},"1":{"10":1,"11":1}}],["混合模式和图层效果等",{"2":{"57":1}}],["避免不必要的重建",{"0":{"68":1}}],["避免不必要的离屏渲染",{"2":{"57":1}}],["避免重建",{"0":{"67":1}}],["避免内部传递",{"0":{"48":1}}],["尤其是在移动设备上",{"2":{"56":1}}],["使得开发者可以创建更丰富的ui体验",{"2":{"55":1}}],["使用了某些混合模式或遮罩",{"2":{"54":1}}],["使用了图层效果",{"2":{"54":1}}],["使用了key属性的widget在组件顺序发生改变的时候都能被正确识别",{"2":{"28":1}}],["使用这个库只需要将想要分帧渲染的widget用frameseparatewidget包裹起来就好了",{"2":{"38":1}}],["使用性能视图",{"2":{"37":1}}],["使用以下命令生成最终的",{"2":{"1":1}}],["例子",{"0":{"93":1},"2":{"85":1}}],["例",{"2":{"54":1}}],["例如没有",{"2":{"90":1}}],["例如const",{"0":{"66":1}}],["例如",{"0":{"78":1},"1":{"79":1},"2":{"46":2,"75":1}}],["某个widget的透明度",{"2":{"54":1}}],["什么是协程",{"0":{"84":1}}],["什么是事件循环",{"0":{"82":1}}],["什么是内部传递",{"0":{"46":1}}],["什么情况下会发生离屏渲染",{"0":{"54":1}}],["它们的区别是",{"2":{"92":1}}],["它会在当前frame绘制完成后进行进行回调",{"2":{"90":1}}],["它的常用状态包括resumed",{"2":{"90":1}}],["它的第一个子组件也是listview",{"2":{"75":1}}],["它允许你在某个异步操作完成时手动发出信号",{"2":{"86":1}}],["它提供了更灵活的图形处理能力",{"2":{"55":1}}],["它通常发生在图形硬件加速的图形绘制中",{"0":{"53":1}}],["它无需等待",{"2":{"32":1}}],["离屏渲染却一定会导致repaint",{"2":{"61":1}}],["离屏渲染出的界面",{"2":{"58":1}}],["离屏渲染通常需要额外的内存和计算资源",{"2":{"56":1}}],["离屏渲染会增加图形渲染的复杂性",{"2":{"56":1}}],["离屏渲染的帧率",{"2":{"59":1}}],["离屏渲染的性能影响",{"0":{"56":1}}],["离屏渲染的目的是允许在屏幕上显示复杂的视觉效果和图形效果",{"2":{"55":1}}],["离屏渲染在某些情况下是必要的",{"0":{"53":1}}],["离屏渲染",{"0":{"53":1}}],["离屏渲染优化",{"0":{"52":1},"1":{"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1,"61":1,"62":1}}],["直到遇到repanintboundary=true的组件为下界",{"2":{"51":1}}],["遇到的第一个repanintboundary=ture组件为上界",{"2":{"51":1}}],["从该节点出发",{"2":{"97":1}}],["从根节点开始进行命中测试",{"2":{"97":1}}],["从外部接收",{"2":{"95":1}}],["从前台退回后台",{"2":{"90":1}}],["从后台切入前台",{"2":{"90":1}}],["从视图树中移除",{"2":{"87":1}}],["从当前setstate的那个statefulwidget对应的renderobject开始",{"2":{"51":1}}],["从网格列表的根部开始",{"2":{"46":1}}],["具体重绘区域规则",{"0":{"51":1}}],["是",{"2":{"87":2,"97":1}}],["是要一起使用的",{"2":{"83":1}}],["是指在屏幕之外或独立于屏幕渲染的一个过程",{"0":{"53":1}}],["是的",{"2":{"50":1}}],["是不对网络图片做本地压缩的",{"2":{"41":1}}],["圆形动画的重绘区域",{"2":{"50":1}}],["重建由于只是对需求的描述",{"2":{"63":1}}],["重回区域的上界和下界",{"2":{"51":1}}],["重绘区域就是上界与下界之间的renderobject",{"2":{"51":1}}],["重新运行",{"2":{"50":1}}],["重启开发服务器查看效果",{"2":{"11":1}}],[">",{"2":{"50":1,"95":1}}],["考察下面这段代码",{"2":{"50":1}}],["考虑下面左边这张小孩投篮的图片",{"2":{"50":1}}],["考虑一个大型的",{"2":{"46":1}}],["画面的重绘区域",{"2":{"50":1}}],["还会继续从堆区中获取到变量",{"2":{"84":1}}],["还是将蓝色框面的人物擦除掉",{"2":{"50":1}}],["还有一个实现库keframe",{"2":{"38":1}}],["锚",{"2":{"48":1}}],["选",{"2":{"62":1}}],["选项",{"2":{"61":1}}],["选择一个特定的单元格作为",{"2":{"48":1}}],["选c",{"2":{"33":1,"61":1}}],["堆栈跟踪",{"2":{"47":1}}],["告诉每个卡片应该使用什么尺寸",{"2":{"46":1}}],["底层的原理认识和经验总结",{"2":{"104":1}}],["底层框架就确定了一个统一的单元格尺寸",{"2":{"46":1}}],["底层解码调用了硬件解码",{"2":{"39":1}}],["有一个参数类型为applifecyclestate的枚举类",{"2":{"90":1}}],["有返回结果可以被继续执行",{"2":{"85":1}}],["有线协程则会将变量继续保存在栈区",{"2":{"84":1}}],["有些手势",{"0":{"77":1}}],["有了这些信息",{"2":{"46":1}}],["有多个线程",{"2":{"32":1}}],["尺寸",{"2":{"46":1}}],["要画出小孩投进篮球时的情景",{"2":{"50":1}}],["要确认你是否有过多的内部传递",{"2":{"47":1}}],["要求网格列表中的",{"2":{"46":1}}],["要知道图片最终是否被gpu缓存",{"2":{"43":1}}],["树中",{"2":{"46":1}}],["网格列表时",{"2":{"46":1}}],["卡片",{"2":{"46":2}}],["卡帧现象就这么消除了",{"2":{"38":1}}],["称为",{"2":{"45":1}}],["尽可能用const",{"0":{"66":1}}],["尽可能减少setstate的粒度",{"0":{"64":1}}],["尽可能将其限制在更小的区域",{"2":{"57":1}}],["尽可能在",{"2":{"45":1}}],["尽量避免频繁的动画和变换",{"2":{"57":1}}],["尽量减少由内部操作引起的布局传递",{"0":{"45":1},"1":{"46":1,"47":1,"48":1,"49":1}}],["特别是网格列表和列表",{"2":{"45":1}}],["最后",{"2":{"45":1}}],["最后面这个人呆在一个叫gpu的车间里面",{"2":{"19":1}}],["传递大小信息",{"2":{"45":1}}],["传递约束条件",{"2":{"45":1}}],["向下遍历子组件",{"2":{"51":1}}],["向下层",{"2":{"45":1}}],["向上遍历父组件",{"2":{"51":1}}],["向上层",{"2":{"45":1}}],["然后再将其合并到屏幕上",{"2":{"54":1}}],["然后重新打印",{"2":{"50":1}}],["然后在custompaint构造函数外包一层repaintboundary",{"2":{"50":1}}],["然后在篮筐下面绘制人物的新状态",{"2":{"50":1}}],["然后在篮筐下面重新画出小孩投进篮球时的神态和表情",{"2":{"50":1}}],["然后在其周围布置其他子单元",{"2":{"48":1}}],["然后",{"2":{"45":1,"88":1}}],["首先定位子锚点",{"2":{"48":1}}],["首先",{"2":{"45":1}}],["时当前组件都会通过命中测试",{"2":{"92":1}}],["时",{"2":{"45":1,"46":1,"54":1,"92":3}}],["你有几个选择来避免内部传递",{"2":{"48":1}}],["你想要所有单元格都具有或大或小的效果",{"2":{"46":1}}],["你甚至可能已经记住了",{"2":{"45":1}}],["你可能已经熟悉了在创建",{"2":{"45":1}}],["你无法直接与",{"2":{"23":1}}],["编写一个自定义渲染对象",{"2":{"48":1}}],["编程",{"2":{"45":1}}],["编辑",{"2":{"10":1}}],["则当前节点会通过命中测试",{"2":{"98":1}}],["则当前组件便会通过命中测试",{"2":{"92":1}}],["则命中测试逻辑为",{"2":{"98":1}}],["则后续的事件分发将不会分发给自己",{"2":{"97":1}}],["则点击也有相应",{"2":{"93":1}}],["则点击无响应",{"2":{"93":1}}],["则通过addpersistentframecallback实现",{"2":{"90":1}}],["则是在",{"2":{"90":1}}],["则会沿着上次离开时指针指向的位置继续执行",{"2":{"85":1}}],["则去调度执行其他",{"2":{"85":1}}],["则表示有任务需要等待",{"2":{"85":1}}],["则该显示区域会呈现为闪烁的棋盘网格",{"2":{"43":1}}],["则gpu有可能将图片缓存到显存",{"0":{"43":1}}],["只有一个孩子",{"2":{"98":1}}],["只回调一次",{"2":{"90":1}}],["只是进行",{"2":{"85":1}}],["只需要间隔一段时间来检查一下有没有结果返回即可",{"2":{"81":1}}],["只在必要的情况下才使用透明度",{"2":{"57":1}}],["只将materialapp的checkerboardrastercacheimages参数设置为true",{"2":{"43":1}}],["只设置memcachedheight时",{"2":{"41":1}}],["只设置memcachedwidth时",{"2":{"41":1}}],["外面包裹一个repaintboundary",{"0":{"43":1}}],["让gpu将频繁使用的图片存到gpu的显存里面",{"0":{"43":1}}],["想快速知道哪些图片的分辨率超过了其实际的显示的分辨率",{"2":{"42":1}}],["想要了解更多信息",{"2":{"21":1}}],["却可以大幅降低网络流量费用",{"2":{"42":1}}],["综上",{"2":{"42":1}}],["服务端裁剪压缩要求按照图片显示空间所占的物理像素获取对应大小的图片",{"0":{"42":1}}],["服务器即可",{"2":{"8":1}}],["可见的",{"2":{"90":1}}],["可以用做fps监测",{"2":{"90":1}}],["可以用全局变量或其他不会在某段时间中销毁的变量引用起来",{"0":{"67":1}}],["可以发现",{"2":{"90":1}}],["可以发现包裹repaintboundary之后的重绘区域缩小为mypainter动画的区域",{"2":{"50":1}}],["可以试试",{"2":{"87":1}}],["可以将异步任务封装为future对象",{"2":{"83":1}}],["可以自己向",{"2":{"82":1}}],["可以实时追踪widget的重建次数",{"2":{"63":1}}],["可以对原像素进行boxfit",{"2":{"41":1}}],["可能不同",{"2":{"92":1}}],["可能在某些条件下立刻宣布胜出",{"0":{"77":1}}],["可能实现吗",{"0":{"36":1}}],["可能正在渲染第",{"2":{"32":1}}],["该方法主要用于处理手势",{"2":{"97":1}}],["该数据序列本质上是函数的生成结果",{"2":{"95":1}}],["该组件不支持按照boxfit",{"2":{"41":1}}],["该线程包括开发者写下的代码和",{"2":{"22":1}}],["会从根节点",{"2":{"97":1}}],["会被多次调用",{"2":{"88":1}}],["会被调用",{"2":{"75":1}}],["会在initstate",{"2":{"87":1}}],["会在state对象被插入视图树的时候调用",{"2":{"87":1}}],["会立即执行",{"2":{"87":1}}],["会同步执行async的代码块",{"2":{"85":1}}],["会继续从栈中取出调用",{"2":{"84":1}}],["会将当前变量放在堆区",{"2":{"84":1}}],["会胜出",{"2":{"75":2}}],["会调用savelayer",{"2":{"54":1}}],["会调用",{"2":{"54":1,"97":2}}],["会按照设置的缓存宽高压缩裁剪图片并缓存起来",{"2":{"41":1}}],["会有什么不同",{"2":{"29":1}}],["反之",{"2":{"41":1}}],["缓存在磁盘里面",{"0":{"41":1}}],["缓存清理",{"2":{"12":1}}],["请在",{"2":{"47":1}}],["请求过的图片",{"0":{"41":1}}],["请参阅",{"2":{"21":1}}],["所以直接调用child",{"2":{"98":1}}],["所以它们的区别就看",{"2":{"92":1}}],["所以我们可以在这里做一些初始化工作",{"2":{"87":1}}],["所以在这里",{"2":{"87":1}}],["所以网络请求这样的异步操作可以使用async",{"2":{"85":1}}],["所以",{"2":{"84":1,"88":1}}],["所以一个简单的原则就是同一个手势应该只有一个手势识别器生效",{"2":{"75":1}}],["所以每一帧当然也只有一颗layer树",{"2":{"62":1}}],["所以离屏渲染对性能的损耗大多数情况下是轻微的",{"2":{"59":1}}],["所以布局代码执行了一次传递",{"2":{"46":1}}],["所以解码效率比较高",{"2":{"39":1}}],["所占用的空间和流量是非常高的",{"0":{"42":1}}],["所有单元格的尺寸都将相对于这个单元格",{"2":{"48":1}}],["所有的widget都会参与布局",{"2":{"27":1}}],["所有现代浏览器",{"2":{"13":1}}],["所有图片资源",{"2":{"2":1}}],["所有",{"2":{"1":1,"2":1}}],["像image",{"2":{"39":1}}],["果然在哪里套路都一样",{"2":{"38":1}}],["小实验",{"0":{"58":1},"1":{"59":1,"61":1,"62":1}}],["小于1",{"2":{"54":1}}],["小于16",{"2":{"38":1}}],["小测验",{"0":{"26":1,"31":1,"49":1,"60":1},"1":{"27":1,"28":1,"29":1,"32":1,"33":1,"61":1,"62":1}}],["每隔一秒打印一个",{"2":{"95":1}}],["每帧都回调",{"2":{"90":1}}],["每当",{"2":{"88":1}}],["每一帧只对应一颗layer树",{"2":{"62":1}}],["每一个手势识别器",{"2":{"75":2}}],["每一个containerlayer对应一次光栅化过程",{"2":{"62":1}}],["每一个layer对应一次光栅化过程",{"2":{"62":1}}],["每一个widget只占用10ms",{"2":{"38":1}}],["每行显示3个方格",{"2":{"58":1}}],["每个",{"2":{"46":1,"82":1}}],["每个element会对应生成一个renderobect",{"2":{"27":1}}],["每个widget对应生成一个element",{"2":{"27":2}}],["分别放到第1帧",{"2":{"38":1}}],["分帧渲染优化",{"0":{"38":1}}],["超出了一帧的时间16",{"2":{"38":1}}],["实时",{"2":{"90":1}}],["实时frame绘制回调",{"2":{"90":1}}],["实时预览",{"2":{"10":1}}],["实际上取决于第一次移动时两个轴上的位移分量",{"2":{"75":1}}],["实际上",{"2":{"61":1}}],["实现分帧渲染上屏",{"2":{"37":1}}],["官方文档提到opacity可能会导致调用savelayer",{"2":{"61":1}}],["官方文档",{"2":{"37":1}}],["包含一个事件循环以及两个事件队列",{"2":{"82":1}}],["包含内容",{"2":{"2":1}}],["包体积优化不在此列",{"2":{"37":1}}],["内存警告都可以通过这个实现进行回调",{"2":{"90":1}}],["内存警告回调",{"2":{"90":1}}],["内存大小优化",{"2":{"37":1}}],["内部添加事件",{"2":{"82":1}}],["内部的时间线事件将被标记为",{"2":{"47":1}}],["内部",{"2":{"46":1}}],["内部传递",{"2":{"45":1}}],["内容",{"2":{"1":1}}],["本地化语言变化",{"2":{"90":1}}],["本地预览",{"0":{"4":1}}],["本文中的重建指的是调用构造函数生成一个对象",{"2":{"63":1}}],["本文章主要围绕官方的",{"2":{"37":1}}],["本文章所讲的性能优化指的是app响应用户操作和渲染画面的速度",{"2":{"37":1}}],["如计算",{"2":{"95":1}}],["如旋转",{"2":{"90":1}}],["如想获取",{"2":{"87":1}}],["如点击",{"0":{"77":1}}],["如何处理耗时的操作",{"0":{"71":1},"1":{"72":1,"73":1}}],["如何优化离屏渲染",{"0":{"57":1}}],["如半透明",{"2":{"62":1}}],["如cliprrect",{"2":{"61":1}}],["如阴影",{"2":{"54":1}}],["如下图",{"2":{"51":1}}],["如下图左",{"2":{"50":1}}],["如下代码",{"2":{"36":1}}],["如果任意一个子节点通过了命中测试或者当前节点",{"2":{"98":1}}],["如果一个渲染对象有多个子节点",{"2":{"98":1}}],["如果一帧中只做一个区域的离屏渲染",{"2":{"59":1}}],["如果有的话",{"2":{"98":1}}],["如果没有被添加进去",{"2":{"97":1}}],["如果要再次监听则需要再设置一次",{"2":{"90":1}}],["如果可以被继续执行的话",{"2":{"85":1}}],["如果你希望父子组件同时动",{"0":{"78":1},"1":{"79":1}}],["如果你经常使用",{"2":{"45":1}}],["如果现在滑动这个子listview",{"2":{"75":1}}],["如果对一个组件同时监听水平和垂直方向的拖动手势",{"2":{"75":1}}],["如果手势发生了某个手势",{"2":{"75":1}}],["如果其不会引起element重建的话",{"2":{"63":1}}],["如果layer树总存在导致离屏渲染的widget",{"2":{"62":1}}],["如果repaintboundary是根节点会触发离屏渲染吗",{"2":{"61":1}}],["如果裁剪圆角的话",{"2":{"61":1}}],["如果避免不了离屏渲染",{"2":{"57":1}}],["如果不是手绘的话",{"2":{"50":1}}],["如果不设置memcachedwidth和memcachedheight",{"2":{"41":1}}],["如果同一个显示区域的图片缓存在不但更换",{"2":{"43":1}}],["如果想打印出某个指定widget从开始build到渲染到屏幕上面所花费的时间",{"0":{"36":1}}],["如果子padding的子statefulcolorfulwidget的key",{"2":{"29":1}}],["如果padding",{"2":{"29":1}}],["如果数值相等就认为是同一个key",{"2":{"28":1}}],["如果是同一内存地址就会任务是同一个key",{"2":{"28":1}}],["如果构建出现问题",{"2":{"12":1}}],["布局跟踪",{"2":{"47":1}}],["布局过程中性能代价很大",{"2":{"45":1}}],["布局和约束是如何工作的",{"2":{"45":1}}],["布局优化",{"0":{"44":1},"1":{"45":1,"46":1,"47":1,"48":1,"49":1}}],["布局",{"2":{"36":1}}],["答案是否定的",{"2":{"75":1}}],["答案是显而易见的",{"2":{"50":1}}],["答案是无法直接打印出",{"2":{"36":1}}],["答案解析",{"2":{"32":1,"33":1}}],["思考",{"0":{"36":1}}],["他们都要在",{"2":{"75":2}}],["他们每个渲染需要10ms",{"2":{"38":1}}],["他们是如何协作的",{"0":{"35":1},"1":{"36":1}}],["他们的效果图和实现代码如下",{"0":{"29":1}}],["三棵树",{"0":{"34":1},"1":{"35":1,"36":1}}],["另外一种会调用",{"2":{"88":1}}],["另外",{"2":{"33":1,"41":1}}],["光栅化过程是由cpu完成的",{"2":{"62":1}}],["光栅化才是将绘制命令转换为屏幕上显示的像素的",{"2":{"33":1}}],["光栅化就是将矢量图转换为对应",{"2":{"33":1}}],["对应的",{"2":{"97":1}}],["对应矢量图",{"2":{"33":1}}],["对象的",{"2":{"97":1}}],["对象",{"2":{"95":1,"97":1}}],["对用于构建子widget的build方法的执行流不要调用widget",{"0":{"65":1}}],["对性能的消耗并不像我想象中的多",{"2":{"59":1}}],["对cached",{"2":{"41":1}}],["对于开发者来说就是使用更方便",{"2":{"90":1}}],["对于例如listview和gridview这样的列表widget",{"0":{"68":1}}],["对于不能被const修饰的widget构造函数调用生成的widget对象",{"0":{"67":1}}],["对于以下两段列表布局代码",{"2":{"49":1}}],["对于一些",{"2":{"45":1}}],["对于绘制",{"0":{"33":1}}],["对于渲染流管线",{"0":{"32":1}}],["绘制回调",{"2":{"90":2}}],["绘制事件",{"2":{"82":1}}],["绘制了一个静态正方形和一个动画圆形叠加的画面",{"2":{"50":1}}],["绘制边界",{"0":{"50":1},"1":{"51":1}}],["绘制其实就是绘制命令打包",{"2":{"33":1}}],["绘制产物是绘制命令变换的集合",{"2":{"33":1}}],["绘制是在layer上进行的",{"2":{"33":1}}],["绘制就是光栅化",{"2":{"33":1}}],["与光栅化",{"0":{"33":1}}],["帧绘制回调",{"2":{"90":1}}],["帧了",{"2":{"32":1}}],["帧",{"2":{"32":1}}],["流水线",{"2":{"32":1}}],["为事件触发的坐标",{"2":{"98":1}}],["为",{"2":{"92":4}}],["为此",{"2":{"75":1}}],["为了优化性能",{"0":{"57":1}}],["为了提高效率",{"2":{"32":1}}],["为什么需要离屏渲染",{"0":{"55":1}}],["为正确项",{"2":{"32":1}}],["负责处理i",{"2":{"82":1}}],["负责合成并渲染",{"2":{"32":1}}],["负责构建",{"2":{"32":1}}],["虽然cpu里面有个线程叫raster线程",{"2":{"33":1}}],["虽然",{"2":{"32":1}}],["下面是renderview的hittest",{"2":{"98":1}}],["下面我们看一下命中测试的过程",{"2":{"97":1}}],["下面我们通过一个实例来理解一下",{"2":{"92":1}}],["下的",{"2":{"50":1}}],["下层",{"2":{"45":1}}],["下列关关于layer树与光栅化的说法",{"0":{"62":1}}],["下列关于widget",{"0":{"27":1,"28":1}}],["下列说法正确的是",{"0":{"33":1,"61":1}}],["下一帧的渲染无法开始",{"2":{"32":1}}],["下一帧的渲染已经开始",{"2":{"32":2}}],["因此在不必要的情况下过度使用离屏渲染可能会导致应用程序性能下降",{"2":{"56":1}}],["因此可能对性能产生负面影响",{"2":{"56":1}}],["因此需要谨慎使用",{"0":{"53":1}}],["因此有可能一帧的渲染未结束",{"2":{"32":2}}],["因为",{"2":{"98":1}}],["因为这个会影响",{"2":{"88":1}}],["因为这时子listview会胜出而获得滑动事件的处理权",{"2":{"75":1}}],["因为每一次离屏渲染就是一次光栅化的过程",{"2":{"62":1}}],["因为渲染一定会需要经过paint这个步骤",{"2":{"61":1}}],["因为它们可能触发不必要的离屏渲染",{"2":{"57":1}}],["因为它为",{"2":{"23":1}}],["因为该各个widget的构建",{"2":{"36":1}}],["渲染树的命中测试流程就是父节点",{"2":{"98":1}}],["渲染树命中测试过程",{"0":{"98":1}}],["渲染树命中测试完毕后",{"2":{"97":1}}],["渲染树命中测试",{"2":{"97":1}}],["渲染树",{"2":{"97":1}}],["渲染完成",{"2":{"32":1}}],["渲染流程",{"0":{"30":1},"1":{"31":1,"32":1,"33":1}}],["渲染管线上总共有2个线程在工作",{"2":{"32":1}}],["渲染管线上总共有4个线程在工作",{"2":{"32":1}}],["渲染管线上总共有两个线程在工作",{"2":{"32":1}}],["渲染管线",{"0":{"19":1},"1":{"20":1,"21":1,"22":1,"23":1,"24":1}}],["解析",{"2":{"29":1}}],["换成不重复的globalkey或者valuekey会有不一样的结果吗",{"2":{"29":1}}],["换成",{"2":{"29":1}}],["色块的颜色会改变吗",{"2":{"29":1}}],["help",{"2":{"102":1}}],["height",{"2":{"29":1,"50":2,"93":1}}],["hittarget",{"2":{"92":4}}],["hittestentry",{"2":{"98":1}}],["hittestbehavior",{"2":{"92":1,"93":1,"94":2}}],["hittest",{"2":{"92":4,"97":6,"98":5}}],["hittestresult",{"2":{"92":1,"97":2,"98":1}}],["hittestchildren",{"2":{"92":2}}],["hittestself",{"2":{"92":3}}],["histtestbehavor有三个属性",{"0":{"92":1}}],["highlight",{"2":{"50":1}}],["h",{"2":{"85":2}}],["handleevent",{"2":{"75":1}}],["https",{"2":{"20":1,"29":1,"37":3,"38":1,"51":1,"94":1,"95":1}}],["http",{"2":{"4":1}}],["html",{"0":{"1":1},"2":{"1":2,"2":1}}],["85",{"2":{"94":1}}],["8",{"2":{"29":2,"58":1,"94":1,"95":1}}],["=",{"2":{"29":3,"36":2,"50":3,"54":1,"72":1,"73":11,"86":2,"95":6,"98":1}}],["=>",{"2":{"29":2,"90":2}}],["xcassets",{"2":{"103":1}}],["xcworkspace",{"2":{"103":1}}],["xcode",{"2":{"103":1}}],["x3c",{"2":{"29":4,"50":1,"58":1,"72":1,"73":3,"85":1,"86":1,"90":5,"95":11}}],["x26",{"2":{"1":2,"10":2,"15":2}}],["问",{"0":{"29":1}}],["方法的递归过程",{"2":{"98":1}}],["方法的场景是",{"2":{"88":1}}],["方法中不断调用子节点",{"2":{"98":1}}],["方法主要功能是",{"2":{"97":1}}],["方法",{"2":{"97":2}}],["方法之后立即调用",{"2":{"88":1}}],["方法会在",{"2":{"88":1}}],["方便element在资源池里面调度",{"2":{"28":1}}],["方式",{"0":{"4":1,"5":1,"6":1,"7":1,"8":1}}],["才需要使用key属性",{"2":{"28":1}}],["且需要改变组件渲染的顺序",{"2":{"28":1}}],["当发生用户事件时",{"2":{"97":1}}],["当发生指针事件时",{"2":{"75":2}}],["当下一个数据项准备就绪时",{"2":{"95":1}}],["当给",{"2":{"93":1}}],["当前节点都会被添加到",{"2":{"92":1}}],["当前组件通过命中测试",{"2":{"92":1}}],["当前组件是否能通过命中测试完全取决于",{"2":{"92":1}}],["当前对用户不可见",{"2":{"90":1}}],["当前线程不会停止执行",{"2":{"81":1}}],["当前线程会被挂起",{"2":{"81":1}}],["当要创建新的",{"2":{"87":1}}],["当执行到await时",{"2":{"85":1}}],["当再次回到当前位置时",{"2":{"84":1}}],["当我们斜着拖动时哪个方向的拖动手势回调会被触发",{"2":{"75":1}}],["当有",{"2":{"54":1}}],["当然如果被包裹的widget的尺寸会自适应自身内容的大小",{"2":{"38":1}}],["当",{"2":{"32":1,"54":1,"88":1}}],["当点击按钮",{"2":{"29":1}}],["当两个兄弟组件都需要表现各自的不同属性",{"2":{"28":1}}],["当应用创建和展示场景的时候",{"2":{"22":1}}],["而去掉颜色",{"2":{"93":1}}],["而在android开发中",{"2":{"90":1}}],["而且只执行一次",{"2":{"87":2}}],["而async",{"2":{"84":1}}],["而我们的操作系统存在阻塞式调用和非阻塞式调用",{"2":{"81":1}}],["而需要使用特殊的",{"0":{"78":1},"1":{"79":1}}],["而不给其他手势竞争的机会",{"0":{"77":1}}],["而不是用入参width和height写死",{"2":{"38":1}}],["而不是",{"2":{"16":1}}],["而clip",{"2":{"61":1}}],["而是拷贝一张原图",{"2":{"50":1}}],["而是只能通过注释掉该widget的构建",{"2":{"36":1}}],["而合成就是将打包过的命令二次打包",{"2":{"33":1}}],["而offsetlayer上不能直接绘制图形",{"2":{"33":1}}],["而objectkey是对比对象的数值",{"2":{"28":1}}],["而",{"2":{"32":1}}],["而unmount方法是将自身存放到资源池",{"2":{"27":1}}],["不可见并不能响应用户的输入",{"2":{"90":1}}],["不同语言有不同的处理方式",{"0":{"71":1},"1":{"72":1,"73":1}}],["不仅仅是可见的卡片",{"2":{"46":1}}],["不一定生成renderoject",{"2":{"27":1}}],["不要阻塞这个线程",{"2":{"22":1}}],["不要加",{"2":{"12":1}}],["第二步",{"2":{"97":1}}],["第二版",{"2":{"94":1}}],["第二章",{"0":{"37":1}}],["第一步",{"2":{"97":1}}],["第一次创建的时候",{"2":{"88":1}}],["第一章",{"0":{"19":1},"1":{"20":1,"21":1,"22":1,"23":1,"24":1}}],["第五章",{"0":{"74":1,"91":1}}],["第三章",{"0":{"69":1}}],["第三方文档",{"2":{"37":1}}],["第2节",{"0":{"44":1,"50":1,"52":1,"75":1,"80":1,"95":1},"1":{"45":1,"46":1,"47":1,"48":1,"49":1,"51":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1,"61":1,"62":1,"76":1,"77":1,"78":1,"79":1,"81":1,"82":1,"83":1,"84":1,"85":1,"86":1}}],["第2帧",{"2":{"38":1}}],["第4帧中去渲染",{"2":{"38":1}}],["第3帧",{"2":{"38":1}}],["第3节",{"0":{"25":1,"39":1},"1":{"26":1,"27":1,"28":1,"29":1,"40":1,"41":1,"42":1,"43":1}}],["第7节",{"0":{"38":1}}],["第1节",{"0":{"30":1,"34":1,"63":1,"70":1,"96":1},"1":{"31":1,"32":1,"33":1,"35":1,"36":1,"64":1,"65":1,"66":1,"67":1,"68":1,"71":1,"72":1,"73":1,"97":1,"98":1}}],["上的每一个节点并对它们进行命中测试",{"2":{"97":1}}],["上面已经说过",{"2":{"75":1}}],["上只执行一次布局传递",{"2":{"45":1}}],["上层",{"2":{"45":2}}],["上",{"2":{"24":1}}],["常见的屏幕旋转",{"2":{"90":1}}],["常见的有",{"2":{"24":1}}],["常见问题",{"0":{"14":1},"1":{"15":1,"16":1,"17":1}}],["认为该线程运行在",{"2":{"23":1}}],["但其",{"2":{"92":1}}],["但没有一个视图具",{"2":{"90":1}}],["但如果是执行大量耗时同步操作的话",{"2":{"85":1}}],["但如果该线程变慢",{"2":{"23":1}}],["但在",{"2":{"82":1}}],["但也可能会对性能产生负面影响",{"0":{"53":1}}],["但有时需要再次传递",{"2":{"45":1}}],["但不是一定的",{"0":{"43":1}}],["但不一定会参与渲染画面",{"2":{"27":1}}],["但核心渲染管线涉及",{"2":{"32":1}}],["但是无论",{"2":{"92":1}}],["但是视图并不存在",{"2":{"90":1}}],["但是在后台继续活动中",{"2":{"90":1}}],["但是这时",{"2":{"87":1}}],["但是",{"2":{"62":1}}],["但是如果把这4个widget",{"2":{"38":1}}],["但是当前帧的渲染未结束前",{"2":{"32":1}}],["但是能理解",{"2":{"23":1}}],["但我们重新将它命名为",{"2":{"23":1}}],["进行栅格化",{"2":{"23":1}}],["这本书记录我在过程中积累的对",{"2":{"104":1}}],["这本书记录我在过程中积累的对flutter底层的原理认识的和经验总结",{"2":{"99":1}}],["这一行两秒后才打印",{"2":{"86":1}}],["这一行紧接着上一个print打印",{"2":{"86":1}}],["这一行一开始就打印",{"2":{"86":1}}],["这就是协程的一个语法糖",{"2":{"83":1}}],["这时只有子listview会动",{"2":{"75":1}}],["这些配置数据",{"2":{"87":1}}],["这些效果可能不容易直接在屏幕上绘制",{"2":{"55":1}}],["这些产出物的名字依次叫三棵树",{"2":{"19":1}}],["这需要在一个单独的缓冲区中合成图像",{"2":{"54":1}}],["这可能会降低性能",{"2":{"45":1}}],["这让我想起了分期买房",{"2":{"38":1}}],["这个过程称为",{"2":{"97":1}}],["这个过程是在cpu完成的",{"2":{"33":1}}],["这个过程是在gpu完成的",{"2":{"33":1}}],["这个我们已经在上面详细介绍过了",{"2":{"92":1}}],["这个函数会在每次绘制frame结束后进行回调",{"2":{"90":1}}],["这个函数在state的生命周期中只会被调用一次",{"2":{"87":1}}],["这个枚举类是flutter对app生命周期状态的封装",{"2":{"90":1}}],["这个操作会阻塞到后面的任务",{"2":{"83":1}}],["这个可以说是最简单高效的优化方法了",{"2":{"38":1}}],["这个线程却只为光栅化做准备",{"2":{"33":1}}],["这个线程将不会显示在性能调试工具performance",{"2":{"24":1}}],["这个线程之前被叫做",{"2":{"23":1}}],["这种",{"2":{"32":1}}],["这两者是异步并行的",{"2":{"32":1}}],["这是因为许多开发者错误的",{"2":{"23":1}}],["并能响应用户的输入",{"2":{"90":1}}],["并没有渲染",{"2":{"87":1}}],["并且只会回调一次",{"2":{"90":1}}],["并且",{"2":{"90":1}}],["并且不响应用户行为",{"2":{"90":1}}],["并且通过回调可以判断生命周期链条",{"2":{"90":1}}],["并且可以通过future对象等待该信号",{"2":{"86":1}}],["并且有自己的上下文环境",{"2":{"85":1}}],["并且都是stateflulwidget的时候",{"2":{"28":1}}],["并不是一直在和用户进行交互",{"2":{"81":1}}],["并不是真正完成光栅化",{"2":{"33":1}}],["并分别将任务1和任务2分配给它们",{"2":{"73":1}}],["并闪烁",{"2":{"59":1}}],["并观察火焰图上面的帧率然后将clipbehavior",{"2":{"58":1}}],["并打开hightlight",{"2":{"50":1}}],["并打印对比注释前后渲染一帧所需的时间估算渲染时间差",{"2":{"36":1}}],["并查看应用程序的",{"2":{"47":1}}],["并再次重新访问所有的网格单元",{"2":{"46":1}}],["并在性能图层的最顶栏显示该线程",{"2":{"23":1}}],["并将它交给",{"2":{"23":1}}],["并将图层树发送到",{"2":{"22":1}}],["一般在执行当前函数时就会将变量直接分配到堆区",{"2":{"84":1}}],["一般用户上传的图片如果不经过压缩",{"0":{"42":1}}],["一旦有一个竞争者胜出",{"2":{"75":1}}],["一旦你启用跟踪",{"2":{"47":1}}],["一颗layer树可能要进行多次光栅化过程",{"2":{"62":1}}],["一定会导致离屏渲染",{"2":{"61":2}}],["一定是开发者",{"2":{"23":1}}],["一页渲染完成就需要40ms",{"2":{"38":1}}],["一个对象是否可以响应事件",{"2":{"97":1}}],["一个flutterapp只能产生唯一一颗layer树",{"2":{"62":1}}],["一个网格列表应该有统一大小的单元格",{"2":{"46":1}}],["一个包含设备无关的渲染命令的轻量对象",{"2":{"22":1}}],["一个画面帧",{"2":{"19":1}}],["以",{"2":{"85":1}}],["以下是我在小米mi6x手机上测得的帧率",{"0":{"59":1}}],["以下是一些关于离屏渲染的要点",{"2":{"53":1}}],["以下情况可能发生离屏渲染",{"0":{"54":1}}],["以下说法正确的是",{"0":{"32":1}}],["以见效性能消耗",{"2":{"50":1}}],["以了解执行了多少次布局传递",{"2":{"47":1}}],["以待下次需要时重新调用",{"2":{"27":1}}],["以避免阻塞",{"2":{"24":1}}],["以前叫",{"0":{"23":1}}],["以及实时frame绘制回调两种机制",{"2":{"90":1}}],["以及state的当前状态",{"2":{"88":1}}],["以及event",{"2":{"82":1}}],["以及",{"2":{"21":1}}],["route",{"2":{"90":1}}],["row",{"2":{"29":1}}],["rawgesturedetector",{"0":{"78":1},"1":{"79":1}}],["raster",{"0":{"23":1},"2":{"23":2,"24":1}}],["replacing",{"2":{"103":1}}],["repaintboundary包裹的widget一定会发生离屏渲染",{"2":{"61":1}}],["repaintboundary组件的作用就是缩小重绘区域",{"2":{"50":1}}],["repaint选项",{"2":{"50":2}}],["repaint",{"2":{"50":1}}],["reference",{"2":{"102":1}}],["resources",{"2":{"102":1}}],["resumed",{"2":{"90":4}}],["result2",{"2":{"73":1}}],["result1",{"2":{"73":1}}],["result",{"2":{"72":2,"73":10,"97":3,"98":3}}],["rejectgesture",{"2":{"75":1}}],["receiveport2",{"2":{"73":3}}],["receiveport1",{"2":{"73":3}}],["receiveport",{"2":{"73":4}}],["rebuilds",{"2":{"63":1}}],["red",{"2":{"58":1}}],["renderobject",{"2":{"97":2}}],["renderobject的关系",{"0":{"35":1},"1":{"36":1}}],["renderview",{"2":{"97":4,"98":1}}],["rendering",{"0":{"53":1}}],["required",{"2":{"50":1}}],["reversed",{"2":{"29":1}}],["return",{"2":{"29":2,"50":2,"58":2,"72":1,"86":1,"98":1}}],["runner",{"2":{"103":2}}],["runtomax",{"2":{"95":2}}],["runs",{"2":{"5":2}}],["run",{"2":{"1":1,"4":1,"5":3,"6":1,"7":1,"10":3,"18":3}}],["guidance",{"2":{"102":1}}],["gt",{"2":{"90":4}}],["g",{"2":{"85":2}}],["get",{"2":{"102":1}}],["getting",{"0":{"102":1},"2":{"102":1}}],["generators",{"2":{"95":1}}],["generaterandomcolor",{"2":{"29":1}}],["geniterates",{"2":{"95":4}}],["gesturebinding",{"2":{"97":2}}],["gesturedetector",{"2":{"93":1}}],["gesturearenamanager",{"2":{"75":1}}],["gesturearenamember",{"2":{"75":2}}],["gesturerecognizer",{"2":{"75":3}}],["griddelegate",{"2":{"58":1}}],["gridview",{"2":{"58":1}}],["green",{"2":{"50":1,"58":1}}],["gpu",{"0":{"23":1},"2":{"22":1,"23":5,"32":4}}],["github",{"0":{"5":1},"2":{"5":5,"6":1,"7":1}}],["tutorials",{"2":{"102":1}}],["the",{"2":{"102":1,"103":4}}],["then",{"2":{"85":1}}],["this",{"2":{"50":1,"98":1,"102":2,"103":1}}],["tap",{"0":{"77":1}}],["task2",{"2":{"73":2}}],["task1",{"2":{"73":2}}],["tips",{"2":{"59":1}}],["timer",{"2":{"58":3}}],["tiles",{"2":{"29":4}}],["text",{"2":{"54":1}}],["tencent",{"2":{"51":1}}],["true",{"2":{"92":4,"98":1}}],["translucent",{"2":{"92":3}}],["transparent",{"2":{"50":1}}],["trace",{"2":{"47":1}}],["track",{"2":{"47":1,"63":1}}],["tree",{"2":{"22":1,"23":1,"32":1}}],["toask",{"2":{"85":1}}],["tool中的帧火焰图",{"2":{"58":1}}],["tool中的",{"2":{"50":1}}],["tools",{"2":{"36":1,"37":1}}],["tolist",{"2":{"29":1}}],["token",{"2":{"5":1}}],["to",{"2":{"5":1,"102":1}}],["框架根据应用行为生成的代码",{"2":{"22":1}}],["代码中的某处导致的",{"2":{"23":1}}],["代码",{"2":{"22":1}}],["线程模型",{"0":{"70":1},"1":{"71":1,"72":1,"73":1}}],["线程已经在处理第",{"2":{"32":1}}],["线程后",{"2":{"32":1}}],["线程完成当前帧的任务并交给",{"2":{"32":1}}],["线程与渲染流水线的对应关系",{"2":{"24":1}}],["线程或其数据通信",{"2":{"23":1}}],["线程拿到",{"2":{"23":1}}],["线程来渲染到设备上",{"2":{"22":1}}],["线程首先建立一个",{"2":{"22":1}}],["线程在",{"2":{"22":1}}],["线程",{"0":{"22":1,"23":2,"69":1},"2":{"23":2,"24":1,"32":2}}],["文本缩放系数变化",{"2":{"90":1}}],["文档",{"2":{"21":1}}],["文件保存后浏览器会自动刷新",{"2":{"10":1}}],["文件",{"2":{"10":1,"11":1}}],["文件将生成在",{"2":{"1":1}}],["文件后",{"2":{"1":1}}],["的核心机制",{"2":{"104":1}}],["的返回值会影响什么",{"2":{"92":1}}],["的返回值",{"2":{"92":3}}],["的基础上进行了封装",{"2":{"90":1}}],["的基本布局规则",{"2":{"45":1}}],["的好处就是不用",{"2":{"90":1}}],["的渲染效率",{"2":{"88":1}}],["的方法",{"2":{"87":1}}],["的线程中也存在事件循环和消息队列的概念",{"2":{"82":1}}],["的异步操作就是利用非阻塞式调用实现的",{"2":{"81":1}}],["的概念",{"2":{"75":1}}],["的flutter",{"2":{"63":1}}],["的时候",{"2":{"54":1,"87":1}}],["的位置",{"2":{"45":1}}],["的屏幕像素",{"2":{"33":1}}],["的说法正确的是",{"0":{"28":1}}],["的",{"2":{"21":2,"75":1,"82":1,"87":3,"97":1}}],["的代码将会在这里运行",{"2":{"21":1}}],["平台线程实际上就是主线程",{"2":{"21":1}}],["平台线程",{"0":{"21":1}}],["参考链接",{"2":{"95":1}}],["参考",{"0":{"94":1},"2":{"20":1,"38":1,"51":1,"90":1}}],["few",{"2":{"102":1}}],["full",{"2":{"102":1}}],["functions",{"2":{"95":1}}],["future",{"2":{"72":1,"73":1,"83":1,"85":3,"86":2,"87":1,"90":4,"95":4}}],["focus",{"2":{"90":1}}],["for",{"2":{"73":2,"95":1,"102":2}}],["false",{"2":{"90":2,"92":3}}],["factor",{"2":{"50":7}}],["f",{"2":{"85":2}}],["from",{"2":{"73":4}}],["framework认为state已经准备好了",{"2":{"88":1}}],["frame",{"2":{"19":1,"36":1,"90":2}}],["files",{"2":{"103":1}}],["first",{"2":{"73":2,"102":2}}],["fitheight",{"2":{"41":1}}],["fitwidth",{"2":{"41":1}}],["final",{"2":{"36":2,"50":1}}],["flutte3",{"2":{"90":1}}],["flutterchina",{"2":{"94":1}}],["flutter实战",{"2":{"94":1}}],["flutter事件机制",{"2":{"94":1}}],["flutterview",{"2":{"90":1}}],["flutter会通过调用statefulwidget",{"2":{"87":1}}],["flutter性能优化最佳实践",{"2":{"37":2}}],["flutter的三棵树",{"2":{"35":1}}],["flutter绘制了两个并排的widget和一个按钮",{"0":{"29":1}}],["flutter",{"0":{"20":1},"1":{"21":1,"22":1,"23":1,"24":1},"2":{"20":1,"22":1,"32":1,"37":2,"45":3,"50":1,"90":1,"94":2,"97":1,"101":1,"102":5,"103":1,"104":2}}],["flutter渲染流水线",{"2":{"19":1}}],["floatingactionbutton",{"2":{"29":2}}],["图中是每帧同时渲染了50个离屏渲染造成的性能差别",{"2":{"59":1}}],["图中的蓝色框对应就是flutter中的重绘区域边界repaintboundary",{"2":{"50":1}}],["图一",{"2":{"58":1}}],["图三",{"2":{"51":1,"59":1}}],["图形库",{"2":{"23":1}}],["图形处理单元",{"2":{"23":1}}],["图层树",{"2":{"22":1}}],["图层树和上屏",{"2":{"19":1}}],["图片加载速度和本次磁盘空间占用量",{"2":{"42":1}}],["图片在服务端裁剪压缩",{"0":{"42":1}}],["图片的缓存和裁剪压缩只花费很小的代价",{"2":{"42":1}}],["图片的本地缓存",{"0":{"41":1}}],["图片的性能优化可以从以下三个方面入手",{"0":{"40":1},"1":{"41":1,"42":1,"43":1}}],["图片优化",{"0":{"39":1},"1":{"40":1,"41":1,"42":1,"43":1}}],["图片无法加载",{"0":{"16":1}}],["图片路径",{"2":{"12":1}}],["e",{"2":{"85":2}}],["event队列",{"2":{"85":1}}],["event",{"2":{"82":4,"85":1}}],["eagergesturerecognizer",{"0":{"77":1}}],["expensiveoperation",{"2":{"72":2}}],["extends",{"2":{"29":4,"50":1,"58":1}}],["enum",{"2":{"92":1}}],["endtime",{"2":{"36":2}}],["environment",{"2":{"5":1}}],["edgeinsetsdirectional",{"2":{"58":1}}],["edgeinsets",{"2":{"29":2}}],["element和renderobject有限度地缓存起来",{"0":{"68":1}}],["element的deactivate方法是将自身销毁",{"2":{"27":1}}],["element的关系正确的是",{"0":{"27":1}}],["element",{"0":{"35":1},"1":{"36":1},"2":{"27":1}}],["element树和layer树",{"2":{"19":1}}],["产线上的每一个环节有会产生一个中间产出物",{"2":{"19":1}}],["就好像我们为每个元素都有一个单独的yield",{"2":{"95":1}}],["就像activity和fragment一样的",{"2":{"90":1}}],["就像工程流水线上的工人一样",{"2":{"19":1}}],["就会轮循一次",{"2":{"85":1}}],["就会通知其他竞争者失败",{"2":{"75":1}}],["就会发生内部传递",{"2":{"46":1}}],["就产生了卡帧现象",{"2":{"38":1}}],["就是开启一个新的线程",{"2":{"71":1}}],["就是将绘制命令转化为屏幕对应的点阵图",{"2":{"33":1}}],["就是是这条产线最终的产品",{"2":{"19":1}}],["就可以立刻开始准备下一帧的数据",{"2":{"32":1}}],["快速命令参考",{"0":{"18":1}}],["✅",{"0":{"18":1}}],["或类似需要轮询所有单元格的计算",{"2":{"46":1}}],["或向上传递",{"2":{"45":1}}],["或者自定义手势识别器来手动管理",{"0":{"78":1},"1":{"79":1}}],["或者decorationimage这样的图片widget",{"2":{"39":1}}],["或者由父widget限定死的",{"2":{"38":1}}],["或者通过dev",{"2":{"36":1}}],["或者",{"2":{"24":1}}],["或重新构建生产版本",{"2":{"17":1}}],["或更高版本",{"2":{"12":1}}],["检查图片路径是否正确",{"2":{"16":1}}],["检查",{"2":{"15":1}}],["queue高",{"2":{"82":1}}],["queue",{"2":{"82":2}}],["queue事件队列",{"2":{"82":1}}],["queue和microtask",{"2":{"82":1}}],["quot",{"0":{"15":2},"2":{"32":2,"63":2}}],["qq",{"2":{"29":1}}],["q",{"0":{"15":1,"16":1,"17":1}}],["🆘",{"0":{"14":1},"1":{"15":1,"16":1,"17":1}}],["支持的浏览器",{"2":{"13":1}}],["输出",{"2":{"85":1,"95":1}}],["输出大小",{"2":{"13":1}}],["输出目录",{"2":{"2":1}}],["页",{"2":{"13":1}}],["页面切换时也会调用该方法",{"2":{"88":1}}],["页面",{"2":{"2":1,"90":2}}],["总共有50个方格",{"2":{"58":1}}],["总页面数",{"2":{"13":1}}],["总大小",{"2":{"2":1}}],["删除",{"2":{"12":1}}],["没有错误",{"2":{"12":1}}],["确保开发服务器正在运行",{"2":{"17":1}}],["确保开发服务器运行正常",{"2":{"12":1}}],["确保使用",{"2":{"1":1}}],["推荐",{"2":{"12":1}}],["版本",{"2":{"12":1,"15":1}}],["⚠️",{"0":{"12":1}}],["配置",{"2":{"11":1}}],["配置构建设置",{"2":{"6":1,"7":1}}],["中",{"2":{"92":1}}],["中断改变",{"2":{"85":1}}],["中的",{"2":{"97":1}}],["中的状态包括",{"2":{"90":1}}],["中的异步",{"0":{"83":1},"1":{"84":1,"85":1,"86":1}}],["中的帧率",{"2":{"58":1}}],["中线程叫做isolate",{"2":{"82":1}}],["中会识别手势",{"2":{"75":1}}],["中启用",{"2":{"47":1}}],["中执行",{"2":{"22":1}}],["中使用相对路径",{"2":{"12":1}}],["中更新",{"2":{"11":1}}],["中导入",{"2":{"6":1,"7":1}}],["mobile",{"2":{"102":1}}],["mixin",{"2":{"90":1}}],["micro",{"2":{"85":1}}],["microtask",{"2":{"82":2}}],["microsecondssinceepoch",{"2":{"36":2}}],["milliseconds",{"2":{"58":1}}],["mypainter",{"2":{"50":4}}],["mycolor",{"2":{"29":3}}],["mcrosencond",{"2":{"36":1}}],["mts",{"2":{"11":1}}],["md",{"2":{"11":1}}],["max",{"2":{"95":4}}],["mainaxisspacing",{"2":{"58":1}}],["mainthread",{"2":{"21":1}}],["main",{"2":{"5":1,"72":1,"73":1,"82":2,"85":1,"86":1,"95":3}}],["markdown",{"2":{"1":1,"10":1,"12":1}}],["添加新页面",{"0":{"11":1}}],["日常开发",{"0":{"10":1}}],["目录中的所有文件上传到您的",{"2":{"8":1}}],["目录下创建新的",{"2":{"11":1}}],["目录下",{"2":{"1":1}}],["将会被调用",{"2":{"75":1}}],["将会用举行标记处重绘区域",{"2":{"50":1}}],["将结果发送回主isolate",{"2":{"73":2}}],["将拿到的数据传给主线程处理",{"2":{"71":1}}],["将耗时操作放在新的线程里面处理",{"2":{"71":1}}],["将滑出屏幕外的",{"0":{"68":1}}],["将代码中materialapp的checkerboardoffscreenlayers参数设置为true",{"2":{"58":1}}],["将单元格设置为固定大小",{"2":{"48":1}}],["将两个titles数组里面的两个padding",{"2":{"29":1}}],["将",{"2":{"8":1}}],["50",{"2":{"58":1}}],["5秒",{"2":{"13":1}}],["5",{"0":{"8":1,"68":1,"90":1},"2":{"58":2,"73":1,"90":1,"95":4}}],["it",{"2":{"103":1}}],["iterable",{"2":{"95":4}}],["itemcount",{"2":{"58":1}}],["itembuilder",{"2":{"58":1}}],["is",{"2":{"102":2}}],["isolate2",{"2":{"73":2}}],["isolate1",{"2":{"73":2}}],["isolate的显示调用和隐式调用",{"2":{"71":1}}],["isolate",{"0":{"69":1},"2":{"73":12,"82":4}}],["if",{"2":{"95":1,"98":1,"102":1}}],["io",{"2":{"85":2}}],["ios",{"2":{"21":1,"82":2,"87":1,"103":1}}],["i++",{"2":{"73":2,"95":3}}],["import",{"2":{"73":1,"86":1}}],["images",{"2":{"103":1}}],["image的cachedmanager设置缓存策略也很重要",{"2":{"41":1}}],["image就是做这个事情的",{"0":{"41":1}}],["image",{"2":{"12":1,"16":2,"39":1,"41":1,"103":1}}],["in",{"2":{"95":1,"103":3}}],["inactive",{"2":{"90":5}}],["index",{"2":{"58":1}}],["int>",{"2":{"95":5}}],["int",{"2":{"58":1,"72":3,"73":6,"95":5}}],["intrinsics",{"2":{"47":1}}],["inspector",{"2":{"50":1}}],["instance",{"2":{"36":1,"90":2}}],["install",{"2":{"6":2}}],["initstate",{"2":{"29":2,"36":2,"58":2,"87":4}}],["icons",{"2":{"29":1}}],["icon",{"2":{"29":1}}],["i",{"0":{"24":1},"2":{"24":1,"73":6,"95":9}}],["id",{"2":{"5":2}}],["仓库",{"2":{"6":1,"7":1}}],["仓库设置中启用",{"2":{"5":1}}],["3",{"0":{"6":1,"29":1,"43":1,"66":1,"89":1},"2":{"10":1,"13":1,"29":1,"58":1,"94":1,"95":4}}],["→",{"2":{"5":2}}],["own",{"2":{"103":1}}],["o事件",{"2":{"82":1}}],["open",{"2":{"103":1}}],["opening",{"2":{"103":1}}],["operation",{"2":{"86":1}}],["opaque",{"2":{"92":3,"93":1}}],["opacity",{"2":{"54":1,"58":2}}],["option",{"2":{"47":1}}],["offers",{"2":{"102":1}}],["off",{"0":{"53":1}}],["offset",{"2":{"50":1,"97":1,"98":1}}],["olddelegate",{"2":{"50":2}}],["overflowshader",{"2":{"54":1}}],["override",{"2":{"29":5,"36":1,"50":2,"58":2,"97":1}}],["overlay",{"2":{"24":1}}],["o",{"2":{"24":1}}],["o线程",{"0":{"24":1}}],["output",{"2":{"6":1}}],["outputs",{"2":{"5":1}}],["online",{"2":{"102":1}}],["ontap",{"2":{"93":2}}],["onpause",{"2":{"88":1}}],["onpressed",{"2":{"29":1}}],["oncreate",{"2":{"87":1}}],["one",{"2":{"36":1}}],["on",{"2":{"5":3,"102":1}}],["$result2",{"2":{"73":1}}],["$result1",{"2":{"73":1}}],["$result",{"2":{"72":1}}],["$runtimetype",{"2":{"47":1}}],["$timer",{"2":{"58":1}}],["$",{"2":{"5":1,"36":1}}],["add",{"2":{"98":1}}],["addpersistentframecallback",{"2":{"90":1}}],["addpostframecallback",{"2":{"36":1,"90":1}}],["api",{"2":{"90":1,"102":1}}],["application",{"2":{"102":1}}],["applifecyclelistener",{"2":{"90":2}}],["applifecyclestate",{"2":{"90":8}}],["app",{"2":{"90":4,"102":1}}],["app生命周期监听applifecyclelistener",{"0":{"90":1}}],["app中的线程",{"0":{"20":1},"1":{"21":1,"22":1,"23":1,"24":1}}],["abstract",{"2":{"90":1}}],["accessibility",{"2":{"90":1}}],["acceptgesture",{"0":{"78":1},"1":{"79":1},"2":{"75":1}}],["actions",{"2":{"5":5}}],["arena",{"2":{"75":1}}],["article",{"2":{"51":1,"94":1}}],["artifact",{"2":{"5":1}}],["await为例",{"2":{"85":1}}],["await原理",{"0":{"85":1}}],["await就属于无线协程的一种",{"2":{"84":1}}],["await",{"2":{"72":1,"73":4,"83":3,"85":1,"86":1,"95":2}}],["async的代码块本质上也相当于一个函数",{"2":{"85":1}}],["async",{"0":{"85":1},"2":{"72":1,"73":1,"83":2,"85":2,"86":2,"95":4}}],["assets",{"0":{"103":1},"2":{"12":1,"16":2,"39":1,"103":2}}],["also",{"2":{"103":1}}],["alpha",{"2":{"54":1}}],["all",{"2":{"29":2,"58":1}}],["and",{"2":{"102":1,"103":1}}],["android",{"2":{"21":1,"87":1}}],["antialiaswithsavelayer的时候才有可能发生离屏渲染",{"2":{"61":1}}],["antialiaswithsavelayer的区域会被显示为棋盘格",{"2":{"59":1}}],["antialiaswithsavelayer这一行打开",{"2":{"58":1}}],["antialiaswithsavelayer",{"2":{"58":1}}],["animation",{"2":{"50":1}}],["a",{"2":{"15":1,"16":1,"17":1,"27":1,"28":1,"32":2,"33":1,"61":1,"62":1,"85":2,"101":1,"102":4}}],["which",{"2":{"102":1}}],["while",{"2":{"95":3}}],["www",{"2":{"37":1,"38":1}}],["wrappedstatefulkeystate",{"2":{"29":2}}],["wrappedstatefulkeywidget>",{"2":{"29":1}}],["wrappedstatefulkeywidget",{"2":{"29":2}}],["write",{"2":{"5":2,"102":1}}],["win",{"2":{"75":2}}],["widet",{"2":{"63":1}}],["width",{"2":{"29":1,"50":3,"93":1}}],["widget重建指的就是调用widget构造函数生成一个对象",{"2":{"63":1}}],["widget重建优化",{"0":{"63":1},"1":{"64":1,"65":1,"66":1,"67":1,"68":1}}],["widget和裁剪圆角的cliprrect都不一定导致离屏渲染",{"2":{"61":1}}],["widgetsbinding提供了单次frame绘制回调",{"2":{"90":1}}],["widgetsbindingobserver这个类提供的回调函数非常丰富",{"2":{"90":1}}],["widgetsbindingobserver",{"2":{"90":2}}],["widgetsbindingobserver源码分析",{"2":{"90":1}}],["widgetsbinding",{"2":{"36":1,"90":2}}],["widget调换顺序",{"2":{"29":1}}],["widget",{"0":{"35":1,"43":2},"1":{"36":1},"2":{"29":2,"45":8,"46":2,"50":2,"54":1,"58":1,"61":1,"63":1,"87":1,"88":4}}],["widget>",{"2":{"29":1}}],["widget树",{"2":{"19":1}}],["with",{"2":{"5":2,"102":1,"103":2}}],["web",{"2":{"8":1}}],["workflows",{"2":{"5":1}}],["customize",{"2":{"103":1}}],["custompainter",{"2":{"50":1}}],["custompaint",{"2":{"50":1}}],["csdn",{"2":{"94":1}}],["csdn博客",{"2":{"94":1}}],["css",{"2":{"2":1}}],["cpu",{"2":{"85":3}}],["c++",{"2":{"71":1}}],["crossaxisspacing",{"2":{"58":1}}],["crossaxiscount",{"2":{"58":1}}],["createstate",{"2":{"29":2,"87":5}}],["club",{"2":{"94":1}}],["clip开头widget",{"2":{"61":1}}],["clip",{"2":{"58":2,"59":1,"61":1}}],["clipbehavior",{"2":{"58":1,"61":1}}],["clipoval",{"2":{"58":1}}],["cloud",{"2":{"51":1}}],["class",{"2":{"29":3,"50":1,"90":1}}],["can",{"2":{"103":2}}],["canvas",{"2":{"50":3}}],["cached",{"0":{"41":1},"2":{"41":1}}],["cache",{"2":{"12":1}}],["center",{"2":{"50":2}}],["c",{"2":{"27":1,"28":1,"32":1,"33":1,"61":1,"62":1,"85":2}}],["cn",{"2":{"20":1,"37":2}}],["cookbook",{"2":{"102":1}}],["countdownfrom",{"2":{"95":2}}],["covariant",{"2":{"50":1}}],["cover模式对图片原像素进行裁剪",{"2":{"41":1}}],["cost",{"2":{"36":1}}],["completed",{"2":{"86":1}}],["complete",{"2":{"86":1}}],["completer是一个非常有用的工具",{"2":{"86":1}}],["completer",{"0":{"86":1},"2":{"86":9}}],["compute",{"2":{"72":1}}],["com",{"2":{"29":1,"37":1,"38":1,"51":1,"90":1}}],["command",{"2":{"6":2,"7":1}}],["colorfilter",{"2":{"54":1}}],["colorfultilestate",{"2":{"29":3}}],["coloranimation",{"2":{"50":1}}],["colors",{"2":{"50":2,"58":2,"93":1}}],["color",{"2":{"29":2,"50":3,"58":2,"93":1}}],["container设置颜色的时候",{"2":{"93":1}}],["container",{"2":{"29":1,"50":1,"58":2,"93":1}}],["context",{"2":{"29":2,"58":2,"87":1}}],["constructor",{"2":{"29":1}}],["const",{"2":{"29":6,"50":1,"58":3}}],["config",{"2":{"11":1}}],["chip",{"2":{"54":1}}],["children",{"2":{"29":1,"50":1}}],["child",{"2":{"29":3,"50":2,"58":3,"93":1,"98":2}}],["chapter",{"2":{"11":1}}],["checkout",{"2":{"5":1}}],["ci",{"2":{"5":1}}],["l",{"2":{"95":4}}],["lifecycle",{"2":{"90":1}}],["lifecyclestate",{"2":{"90":1}}],["listener",{"2":{"92":1}}],["list",{"2":{"29":1,"90":1}}],["locale",{"2":{"90":1}}],["locale>",{"2":{"90":1}}],["localhost",{"2":{"4":1}}],["loop事件循环",{"2":{"82":1}}],["launch",{"0":{"103":1},"2":{"103":1}}],["lab",{"2":{"102":1}}],["language",{"2":{"95":1}}],["layouts",{"2":{"47":1}}],["layer的图层来分析",{"2":{"36":1}}],["layer合成是指将两个纹理合成到同一张纹理",{"2":{"33":1}}],["layer是绘制产物的载体",{"2":{"33":1}}],["layer",{"2":{"22":1,"23":1,"32":1}}],["latest",{"2":{"5":2}}],["u013066292",{"2":{"94":1}}],["uniquekey",{"2":{"58":1}}],["uniquecolorgenerator",{"2":{"29":1}}],["uikit",{"2":{"21":1}}],["ui",{"0":{"22":1},"2":{"20":1,"22":2,"24":1,"32":3,"45":1,"88":2}}],["url",{"2":{"5":2}}],["upload",{"2":{"5":1}}],["ubuntu",{"2":{"5":2}}],["useful",{"2":{"102":1}}],["uses",{"2":{"5":4}}],["use",{"2":{"1":1,"10":1,"15":1}}],["your",{"2":{"102":2,"103":2}}],["you",{"2":{"102":1,"103":2}}],["yield所做的是将子序列的所有元素插入到当前正在构造的序列中",{"2":{"95":1}}],["yield后面的表达式必须表示另一个子序列",{"2":{"95":1}}],["yield语句将此项发送到数据序列",{"2":{"95":1}}],["yield语句只能用于生成器的函数",{"2":{"95":1}}],["yield",{"0":{"95":1},"2":{"95":5}}],["yamlname",{"2":{"5":1}}],["yml",{"2":{"5":1}}],["在dart语言中",{"2":{"95":1}}],["在命中测试过程中",{"2":{"92":1}}],["在当前方法中是不能获取到",{"2":{"87":1}}],["在视图树中存在",{"2":{"87":1}}],["在flutter中实现同样的需求会更简单",{"2":{"90":1}}],["在flutter中",{"2":{"86":1,"90":1}}],["在回到指针指向的离开位置时",{"2":{"84":1}}],["在这里执行任务2",{"2":{"73":1}}],["在这里执行任务1",{"2":{"73":1}}],["在后台isolate中执行expensiveoperation函数",{"2":{"72":1}}],["在android",{"2":{"63":1}}],["在手机上运行app",{"2":{"58":1}}],["在新图中将人物擦除掉",{"2":{"50":1}}],["在背景图像不变的情况下",{"2":{"50":1}}],["在image",{"0":{"43":1}}],["在有效期之内",{"0":{"41":1}}],["在解码速度方面可以优化的空间也很小",{"2":{"39":1}}],["在每一帧渲染后调用",{"2":{"36":1}}],["在该线程运行",{"2":{"23":1}}],["在性能图层的最低栏展示该线程",{"2":{"22":1}}],["在对应的",{"2":{"11":1}}],["在",{"2":{"5":1,"6":1,"7":1,"11":1,"12":1,"46":1,"82":1,"87":1,"88":1}}],["在项目根目录创建",{"2":{"5":1}}],["在部署前先本地预览构建结果",{"2":{"4":1}}],["point",{"2":{"102":1}}],["powered",{"2":{"100":1}}],["position",{"2":{"97":4,"98":4}}],["post",{"2":{"90":1}}],["pop",{"2":{"90":1}}],["p",{"2":{"37":1,"38":1}}],["project",{"2":{"101":1,"102":2,"103":3}}],["practices",{"2":{"37":1}}],["print",{"2":{"36":1,"58":1,"72":1,"73":2,"85":8,"86":3,"90":2,"93":1,"95":2}}],["preview",{"2":{"4":1,"10":1,"18":1}}],["picturelayer就是光栅化的产物",{"2":{"33":1}}],["plugin",{"2":{"21":1}}],["periodic",{"2":{"58":1}}],["perfomance",{"2":{"63":1}}],["performance",{"2":{"20":1,"37":1}}],["perf",{"2":{"20":1,"37":1}}],["permissions",{"2":{"5":1}}],["png",{"2":{"12":1,"16":2}}],["publish",{"2":{"7":1}}],["push",{"2":{"5":1,"90":1}}],["paused",{"2":{"90":4}}],["paused这三个",{"2":{"90":1}}],["painter",{"2":{"50":1}}],["paint",{"0":{"33":1},"2":{"50":5}}],["padding",{"2":{"29":4,"58":1}}],["page",{"2":{"5":1}}],["pages",{"0":{"5":1},"2":{"5":7}}],["path",{"2":{"5":1}}],["部署到",{"0":{"5":1,"6":1,"7":1}}],["部署方式",{"0":{"3":1},"1":{"4":1,"5":1,"6":1,"7":1,"8":1}}],["查看生产版本",{"2":{"4":1}}],["40",{"2":{"93":2}}],["400",{"2":{"50":2}}],["45",{"2":{"73":1}}],["4a36cce7b76d",{"2":{"37":1,"38":1}}],["4",{"0":{"7":1,"67":1},"2":{"10":1,"95":2,"100":1}}],["4173",{"2":{"4":1}}],["4mb",{"2":{"2":1,"13":1}}],["访问",{"2":{"4":1}}],["1172840",{"2":{"94":1}}],["17",{"2":{"58":1}}],["1775842",{"2":{"51":1}}],["1",{"0":{"4":1,"27":1,"32":1,"41":1,"61":1,"64":1,"87":1,"97":1},"1":{"88":1,"89":1,"90":1},"2":{"10":1,"29":2,"63":1,"73":2,"85":2,"90":1,"94":1,"95":6,"100":1}}],["100",{"2":{"29":2}}],["10",{"2":{"1":1,"10":1,"12":1,"15":1,"72":1,"73":2,"95":1}}],["搜索索引",{"2":{"2":1}}],["java",{"2":{"71":1}}],["javascript",{"2":{"2":1,"71":1}}],["jianshu",{"2":{"37":1,"38":1,"90":1}}],["jobs",{"2":{"5":1}}],["js",{"2":{"1":1,"12":2,"15":1}}],["和android里的",{"2":{"88":1}}],["和source1",{"2":{"82":1}}],["和boxfit",{"2":{"41":1}}],["和keframe插件的分帧渲染优化方案做实践总结",{"2":{"37":1}}],["和渲染是相互并存交叉的",{"2":{"36":1}}],["和",{"2":{"2":1,"12":1,"32":1,"82":2,"83":1,"92":1}}],["21",{"2":{"13":1}}],["21个页面",{"2":{"2":1}}],["2",{"0":{"5":1,"28":1,"33":1,"42":1,"62":1,"65":1,"88":1,"98":1},"2":{"10":1,"29":2,"50":3,"73":2,"86":1,"87":1,"90":1,"94":1,"95":4}}],["200",{"2":{"50":1}}],["20",{"2":{"1":1,"5":1,"10":1,"15":1,"58":1}}],["📊",{"0":{"13":1}}],["🔄",{"0":{"9":1},"1":{"10":1,"11":1}}],["🚀",{"0":{"3":1},"1":{"4":1,"5":1,"6":1,"7":1,"8":1}}],["📂",{"0":{"2":1}}],["📦",{"0":{"1":1}}],["do",{"2":{"103":1}}],["documentation",{"2":{"102":1}}],["doc",{"2":{"29":1}}],["docs",{"2":{"1":1,"4":1,"5":1,"6":1,"7":1,"10":3,"18":3,"20":1,"29":1,"37":2}}],["duration",{"2":{"58":1,"85":2,"86":1,"95":1}}],["dropping",{"2":{"103":1}}],["drawcircle",{"2":{"50":1}}],["drwjhaxlqv25id2jb",{"2":{"29":1}}],["datetime",{"2":{"36":2}}],["dart中的异步操作主要使用future以及async",{"2":{"83":1}}],["dart的多线程对应多isolate",{"2":{"71":1}}],["dartclass",{"2":{"29":1,"58":1}}],["dart",{"0":{"83":1},"1":{"84":1,"85":1,"86":1},"2":{"22":2,"23":1,"36":1,"50":1,"71":1,"73":1,"81":1,"82":2,"86":1,"95":1}}],["d",{"2":{"27":1,"28":1,"33":1,"61":2,"62":2,"85":2}}],["desired",{"2":{"103":2}}],["details",{"2":{"94":1}}],["detached",{"2":{"90":2}}],["defertochild",{"2":{"92":2}}],["deactivate",{"2":{"88":1}}],["delayed",{"2":{"86":1,"87":1,"95":1}}],["debug模式下",{"2":{"63":1}}],["development",{"2":{"102":2}}],["developer",{"2":{"51":1}}],["devtools",{"2":{"37":1,"47":1}}],["dev",{"2":{"10":1,"18":1,"95":1}}],["deployment",{"2":{"5":2}}],["deploy",{"2":{"5":4,"6":1,"7":1}}],["didhavememorypressure",{"2":{"90":1}}],["didchangeaccessibilityfeatures",{"2":{"90":1}}],["didchangeapplifecyclestate回调函数中",{"2":{"90":1}}],["didchangeapplifecyclestate",{"2":{"90":2}}],["didchangelocales",{"2":{"90":1}}],["didchangeplatformbrightness",{"2":{"90":1}}],["didchangetextscalefactor",{"2":{"90":1}}],["didchangemetrics",{"2":{"90":1}}],["didchangedependencie与didupdatewidget的作用",{"0":{"89":1}}],["didchangedependencies则用来专门处理state对象依赖关系变化",{"2":{"87":1}}],["didchangedependencies",{"2":{"87":1,"88":1}}],["didpushroute",{"2":{"90":1}}],["didpoproute",{"2":{"90":1}}],["didupdatewidget",{"2":{"88":1}}],["dispose",{"2":{"88":1}}],["disabledcoloralpha",{"2":{"54":1}}],["dist",{"2":{"1":1,"2":1,"5":1,"6":1,"7":1,"8":1,"12":1}}],["directory",{"2":{"6":1,"7":1,"103":1}}],["by",{"2":{"100":1,"103":2}}],["blog",{"2":{"94":1}}],["blue",{"2":{"93":1}}],["behavior",{"2":{"92":4}}],["best",{"2":{"37":1}}],["bool>",{"2":{"90":4}}],["bool",{"2":{"50":1,"98":1}}],["body",{"2":{"29":1}}],["b",{"2":{"27":1,"28":1,"32":1,"33":1,"61":1,"62":1,"85":2}}],["branches",{"2":{"5":1}}],["builder",{"2":{"58":1}}],["buildbody",{"2":{"50":1}}],["buildcontext",{"2":{"29":2,"58":2}}],["build",{"0":{"88":1},"2":{"1":1,"5":3,"6":2,"7":2,"10":1,"18":1,"29":2,"58":1,"88":6}}],["bashsource",{"2":{"15":1}}],["bashnpm",{"2":{"4":1}}],["bash",{"2":{"1":1,"10":1,"18":1}}],["0xff",{"2":{"54":1}}],["0",{"2":{"1":1,"10":1,"12":1,"15":1,"29":2,"58":3,"73":4,"90":1,"95":7}}],["s",{"2":{"103":1}}],["sync",{"2":{"95":3}}],["successfully",{"2":{"86":1}}],["super",{"2":{"29":3,"36":1,"50":1,"58":1,"97":1}}],["supported",{"0":{"15":1}}],["sleep",{"2":{"85":2}}],["slivergriddelegatewithfixedcrossaxiscount",{"2":{"58":1}}],["spawn",{"2":{"73":2}}],["samples",{"2":{"102":2}}],["savelayer",{"2":{"54":1,"59":1}}],["satisfied",{"2":{"29":1}}],["schedulemicrotask",{"2":{"85":1}}],["screen",{"0":{"53":1,"103":1},"2":{"103":1}}],["scaffold",{"2":{"29":1}}],["square",{"2":{"50":1}}],["selecting",{"2":{"103":1}}],["seconds",{"2":{"85":2,"86":1,"95":1}}],["send",{"2":{"73":2}}],["sendport",{"2":{"73":8}}],["sentiment",{"2":{"29":1}}],["setstate",{"2":{"29":1,"58":1}}],["settings",{"2":{"5":1}}],["setup",{"2":{"5":1}}],["swaptiles",{"2":{"29":2}}],["study",{"0":{"101":1},"1":{"102":1}}],["studio",{"2":{"63":1}}],["stream",{"2":{"95":4}}],["string",{"2":{"90":1}}],["string>",{"2":{"86":1}}],["starting",{"2":{"102":1}}],["started",{"0":{"102":1},"2":{"102":2}}],["starttime",{"2":{"36":2}}],["stack",{"2":{"47":1,"50":1}}],["state对象依赖关系发生变化的时候也会调用",{"2":{"87":1}}],["state的生命周期可以分为4个阶段",{"2":{"87":1}}],["state生命周期|statefulwidget",{"0":{"87":1},"1":{"88":1,"89":1,"90":1}}],["statefulcolorfultile>",{"2":{"29":1}}],["statefulcolorfultile",{"2":{"29":4}}],["statefulwidget呢",{"2":{"29":1}}],["statefulwidget>",{"2":{"29":1,"58":1}}],["statefulwidget",{"2":{"29":2,"87":4,"88":1}}],["state",{"2":{"29":3,"58":2,"87":2,"88":1,"90":1}}],["steps",{"2":{"5":3}}],["skia",{"2":{"23":1}}],["simulatenetworkrequest",{"2":{"86":2}}],["sizedbox",{"0":{"66":1}}],["size",{"2":{"50":7}}],["sidebar",{"2":{"11":1}}],["site",{"2":{"5":1,"7":1}}],["shadermask",{"2":{"54":1}}],["shouldrepaint",{"2":{"50":1}}],["sh",{"2":{"1":1,"10":1,"15":1}}],["source0",{"2":{"82":1}}],["source",{"2":{"1":1,"5":1,"10":1}}],["navigator",{"2":{"103":1}}],["name",{"2":{"5":1}}],["nbsp",{"2":{"100":2}}],["null",{"2":{"98":1}}],["n+1",{"2":{"32":1}}],["n",{"2":{"32":1,"95":8}}],["now",{"2":{"36":2}}],["not",{"0":{"15":1}}],["node",{"2":{"1":1,"5":2,"12":2,"15":1}}],["net",{"2":{"41":1,"94":1}}],["network",{"0":{"41":1},"2":{"39":1,"41":1}}],["netlify",{"0":{"7":1},"2":{"7":1}}],["new",{"2":{"29":1,"101":1}}],["needs",{"2":{"5":1}}],["npm",{"2":{"1":1,"5":2,"6":2,"7":1,"10":3,"18":3}}],["nvm",{"2":{"1":3,"10":3,"15":3}}],["~1",{"2":{"13":1}}],["~3",{"2":{"2":1}}],["~",{"2":{"1":1,"10":1,"15":1}}],["var",{"2":{"95":5}}],["value",{"2":{"50":1,"72":3,"85":1,"90":2}}],["valuekey",{"2":{"29":2}}],["valuekey会对比对象的内存地址",{"2":{"28":1}}],["view",{"2":{"87":1,"102":1}}],["viewdidload",{"2":{"87":1}}],["vitepress",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1},"2":{"1":1,"2":1,"5":2,"6":1,"7":1,"8":1,"11":1,"12":2,"100":1}}],["void>",{"2":{"72":1,"73":1,"85":1,"95":3}}],["void",{"2":{"29":1,"36":1,"50":1,"58":1,"73":2,"86":1,"90":7,"97":1}}],["vm",{"2":{"22":1}}],["v18+",{"2":{"15":1}}],["v18",{"2":{"12":1}}],["very",{"2":{"29":1}}],["vercel",{"0":{"6":1},"2":{"6":1}}],["version",{"2":{"5":1}}],["v20",{"2":{"12":1}}],["v20+",{"2":{"1":1}}],["v2",{"2":{"5":2}}],["v3",{"2":{"5":2}}]],"serializationVersion":2}';export{t as default};

import{_ as e,o as t,c as r,ag as p}from"./chunks/framework.CbQjVMS6.js";const c=JSON.parse('{"title":"第1节:渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"Chapter1/pipeline.md","filePath":"Chapter1/pipeline.md","lastUpdated":1770253889000}'),i={name:"Chapter1/pipeline.md"};function l(n,a,o,s,d,h){return t(),r("div",null,[...a[0]||(a[0]=[p('<h1 id="第1节-渲染流程" tabindex="-1">第1节:渲染流程 <a class="header-anchor" href="#第1节-渲染流程" aria-label="Permalink to &quot;第1节:渲染流程&quot;">​</a></h1><h3 id="小测验" tabindex="-1">小测验 <a class="header-anchor" href="#小测验" aria-label="Permalink to &quot;小测验&quot;">​</a></h3><h4 id="_1-对于渲染流管线-以下说法正确的是" tabindex="-1">1.对于渲染流管线,以下说法正确的是? <a class="header-anchor" href="#_1-对于渲染流管线-以下说法正确的是" aria-label="Permalink to &quot;1.对于渲染流管线,以下说法正确的是?&quot;">​</a></h4><p>A. 渲染管线上总共有两个线程在工作,因此有可能一帧的渲染未结束,下一帧的渲染已经开始</p><p>B.渲染管线上总共有4个线程在工作,因此有可能一帧的渲染未结束,下一帧的渲染已经开始</p><p>C.渲染管线上总共有2个线程在工作,但是当前帧的渲染未结束前,下一帧的渲染无法开始</p><details><summary>答案解析</summary><p>A 为正确项。虽然 Flutter 有多个线程,但核心渲染管线涉及 UI 线程(负责构建 Layer Tree)和 GPU 线程(负责合成并渲染)。为了提高效率,这两者是异步并行的。当 UI 线程完成当前帧的任务并交给 GPU 线程后,它无需等待 GPU 渲染完成,就可以立刻开始准备下一帧的数据。这种&quot;流水线&quot;作业意味着在某一时刻,GPU 可能正在渲染第 N 帧,而 UI 线程已经在处理第 N+1 帧了</p></details><h4 id="_2-对于绘制-paint-与光栅化-下列说法正确的是" tabindex="-1">2.对于绘制(paint)与光栅化,下列说法正确的是? <a class="header-anchor" href="#_2-对于绘制-paint-与光栅化-下列说法正确的是" aria-label="Permalink to &quot;2.对于绘制(paint)与光栅化,下列说法正确的是?&quot;">​</a></h4><p>A.绘制就是光栅化,就是将绘制命令转化为屏幕对应的点阵图</p><p>B.绘制是在layer上进行的,PictureLayer就是光栅化的产物,而OffsetLayer上不能直接绘制图形</p><p>C.layer是绘制产物的载体,绘制产物是绘制命令变换的集合,对应矢量图, 光栅化就是将矢量图转换为对应 的屏幕像素,类似位图,这个过程是在GPU完成的。</p><p>D.layer合成是指将两个纹理合成到同一张纹理,这个过程是在CPU完成的。</p><details><summary>答案解析</summary><p>选C。绘制其实就是绘制命令打包,而合成就是将打包过的命令二次打包。光栅化才是将绘制命令转换为屏幕上显示的像素的。另外,虽然CPU里面有个线程叫Raster线程,这个线程却只为光栅化做准备,并不是真正完成光栅化。</p></details>',13)])])}const m=e(i,[["render",l]]);export{c as __pageData,m as default};
